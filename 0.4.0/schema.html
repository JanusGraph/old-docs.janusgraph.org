<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Schema and Data Modeling</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="basics.html" title="Part&nbsp;II.&nbsp;JanusGraph Basics"><link rel="prev" href="configuration.html" title="Chapter&nbsp;4.&nbsp;Configuration"><link rel="next" href="gremlin.html" title="Chapter&nbsp;6.&nbsp;Gremlin Query Language"><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="https://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="https://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="https://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="https://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right dropdown"><a href="https://docs.janusgraph.org/latest/doc-versions.html">Other Doc Versions</a><div class="dropdown-content"><a href="https://docs.janusgraph.org/latest/index.html">Latest</a><a href="https://docs.janusgraph.org/0.4.0/index.html">Version 0.4.0</a><a href="https://docs.janusgraph.org/0.3.2/index.html">Version 0.3.2</a><a href="https://docs.janusgraph.org/0.3.1/index.html">Version 0.3.1</a><a href="https://docs.janusgraph.org/0.3.0/index.html">Version 0.3.0</a><a href="https://docs.janusgraph.org/0.2.3/index.html">Version 0.2.3</a><a href="https://docs.janusgraph.org/0.2.2/index.html">Version 0.2.2</a><a href="https://docs.janusgraph.org/0.2.1/index.html">Version 0.2.1</a><a href="https://docs.janusgraph.org/0.2.0/index.html">Version 0.2.0</a><a href="https://docs.janusgraph.org/0.1.1/index.html">Version 0.1.1</a><a href="https://docs.janusgraph.org/0.1.0/index.html">Version 0.1.0</a></div></li><li class="header-item-right"><a href="index.html">Documentation (0.4.0)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="basics.html">JanusGraph Basics</a></span> &gt; <span class="breadcrumb-node">Schema and Data Modeling</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="schema"></a>Chapter&nbsp;5.&nbsp;Schema and Data Modeling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="schema.html#_displaying_schema_information">5.1. Displaying Schema Information</a></span></dt><dt><span class="section"><a href="schema.html#_defining_edge_labels">5.2. Defining Edge Labels</a></span></dt><dd><dl><dt><span class="section"><a href="schema.html#_edge_label_multiplicity">5.2.1. Edge Label Multiplicity</a></span></dt></dl></dd><dt><span class="section"><a href="schema.html#_defining_property_keys">5.3. Defining Property Keys</a></span></dt><dd><dl><dt><span class="section"><a href="schema.html#_property_key_data_type">5.3.1. Property Key Data Type</a></span></dt><dt><span class="section"><a href="schema.html#property-cardinality">5.3.2. Property Key Cardinality</a></span></dt></dl></dd><dt><span class="section"><a href="schema.html#_relation_types">5.4. Relation Types</a></span></dt><dt><span class="section"><a href="schema.html#_defining_vertex_labels">5.5. Defining Vertex Labels</a></span></dt><dt><span class="section"><a href="schema.html#_automatic_schema_maker">5.6. Automatic Schema Maker</a></span></dt><dt><span class="section"><a href="schema.html#_changing_schema_elements">5.7. Changing Schema Elements</a></span></dt><dt><span class="section"><a href="schema.html#schema-constraints">5.8. Schema Constraints</a></span></dt></dl></div>

<p>Each JanusGraph graph has a schema comprised of the edge labels, property keys, and vertex labels used therein. A JanusGraph schema can either be explicitly or implicitly defined. Users are encouraged to explicitly define the graph schema during application development. An explicitly defined schema is an important component of a robust graph application and greatly improves collaborative software development. Note, that a JanusGraph schema can be evolved over time without any interruption of normal database operations. Extending the schema does not slow down query answering and does not require database downtime.</p>
<p>The schema type - i.e. edge label, property key, or vertex label - is assigned to elements in the graph - i.e. edge, properties or vertices respectively - when they are first created. The assigned schema type cannot be changed for a particular element. This ensures a stable type system that is easy to reason about.</p>
<p>Beyond the schema definition options explained in this section, schema types provide performance tuning options that are discussed in <a class="xref" href="advanced-schema.html" title="Chapter&nbsp;33.&nbsp;Advanced Schema">Chapter&nbsp;33, <i>Advanced Schema</i></a>.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_displaying_schema_information"></a>5.1.&nbsp;Displaying Schema Information</h2></div></div></div>

<p>There are methods to view specific elements of the graph schema within the management API.
These methods are <code class="literal">mgmt.printIndexes()</code>, <code class="literal">mgmt.printPropertyKeys()</code>, <code class="literal">mgmt.printVertexLabels()</code>, and <code class="literal">mgmt.printEdgeLabels()</code>.
There is also a method that displays all the combined output named <code class="literal">printSchema()</code>.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.printSchema<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_defining_edge_labels"></a>5.2.&nbsp;Defining Edge Labels</h2></div></div></div>

<p>Each edge connecting two vertices has a label which defines the semantics of the relationship. For instance, an edge labeled <code class="literal">friend</code> between vertices A and B encodes a friendship between the two individuals.</p>
<p>To define an edge label, call <code class="literal">makeEdgeLabel(String)</code> on an open graph or management transaction and provide the name of the edge label as the argument. Edge label names must be unique in the graph. This method returns a builder for edge labels that allows to define its multiplicity. The <span class="strong"><strong>multiplicity</strong></span> of an edge label defines a multiplicity constraint on all edges of this label, that is, a maximum number of edges between pairs of vertices. JanusGraph recognizes the following multiplicity settings.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_edge_label_multiplicity"></a>5.2.1.&nbsp;Edge Label Multiplicity</h3></div></div></div>

<div class="itemizedlist"><p class="title"><b>Multiplicity Settings</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>MULTI</strong></span>: Allows multiple edges of the same label between any pair of vertices. In other words, the graph is a <span class="emphasis"><em>multi graph</em></span> with respect to such edge label. There is no constraint on edge multiplicity.
</li><li class="listitem">
<span class="strong"><strong>SIMPLE</strong></span>: Allows at most one edge of such label between any pair of vertices. In other words, the graph is a <span class="emphasis"><em>simple graph</em></span> with respect to the label. Ensures that edges are unique for a given label and pairs of vertices.
</li><li class="listitem">
<span class="strong"><strong>MANY2ONE</strong></span>: Allows at most one outgoing edge of such label on any vertex in the graph but places no constraint on incoming edges. The edge label <code class="literal">mother</code> is an example with MANY2ONE multiplicity since each person has at most one mother but mothers can have multiple children.
</li><li class="listitem">
<span class="strong"><strong>ONE2MANY</strong></span>: Allows at most one incoming edge of such label on any vertex in the graph but places no constraint on outgoing edges. The edge label <code class="literal">winnerOf</code> is an example with ONE2MANY multiplicity since each contest is won by at most one person but a person can win multiple contests.
</li><li class="listitem">
<span class="strong"><strong>ONE2ONE</strong></span>:  Allows at most one incoming and one outgoing edge of such label on any vertex in the graph. The edge label <span class="emphasis"><em>marriedTo</em></span> is an example with ONE2ONE multiplicity since a person is married to exactly one other person.
</li></ul></div>

<p>The default multiplicity is MULTI. The definition of an edge label is completed by calling the <code class="literal">make()</code> method on the builder which returns the defined edge label as shown in the following example.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>follow<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'follow'</span><span class="hl-gremlin-func">)</span>.multiplicity<span class="hl-gremlin-func">(</span>MULTI<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mother<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'mother'</span><span class="hl-gremlin-func">)</span>.multiplicity<span class="hl-gremlin-func">(</span>MANY2ONE<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_defining_property_keys"></a>5.3.&nbsp;Defining Property Keys</h2></div></div></div>

<p>Properties on vertices and edges are key-value pairs. For instance, the property <code class="literal">name='Daniel'</code> has the key <code class="literal">name</code> and the value <code class="literal">'Daniel'</code>. Property keys are part of the JanusGraph schema and can constrain the allowed data types and cardinality of values.</p>
<p>To define a property key, call <code class="literal">makePropertyKey(String)</code> on an open graph or management transaction and provide the name of the property key as the argument. Property key names must be unique in the graph, and it is recommended to avoid spaces or special characters in property names. This method returns a builder for the property keys.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_property_key_data_type"></a>5.3.1.&nbsp;Property Key Data Type</h3></div></div></div>

<p>Use <code class="literal">dataType(Class)</code> to define the data type of a property key. JanusGraph will enforce that all values associated with the key have the configured data type and thereby ensures that data added to the graph is valid. For instance, one can define that the <code class="literal">name</code> key has a String data type.</p>
<p>Define the data type as <code class="literal">Object.class</code> in order to allow any (serializable) value to be associated with a key. However, it is encouraged to use concrete data types whenever possible.
Configured data types must be concrete classes and not interfaces or abstract classes. JanusGraph enforces class equality, so adding a sub-class of a configured data type is not allowed.</p>
<p>JanusGraph natively supports the following data types.</p>
<div class="table"><a name="d5e518"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Native JanusGraph Data Types</b></p><div class="table-contents">

  
  <table summary="Native JanusGraph Data Types" cellpadding="4px" style="border-collapse: collapse;border-top: 1px solid #1b8669; border-bottom: 1px solid #1b8669; border-left: 1px solid #1b8669; border-right: 1px solid #1b8669; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top">Name</th><th style="border-bottom: 1px solid #747474; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>String</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>Character sequence</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Character</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>Individual character</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Boolean</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>true or false</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Byte</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>byte value</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Short</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>short value</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Integer</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>integer value</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Long</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>long value</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Float</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>4 byte floating point number</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Double</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>8 byte floating point number</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Date</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>Specific instant in time (<code class="literal">java.util.Date</code>)</p></td></tr><tr><td style="border-right: 1px solid #747474; border-bottom: 1px solid #747474; " align="left" valign="top"><p>Geoshape</p></td><td style="border-bottom: 1px solid #747474; " align="left" valign="top"><p>Geographic shape like point, circle or box</p></td></tr><tr><td style="border-right: 1px solid #747474; " align="left" valign="top"><p>UUID</p></td><td style="" align="left" valign="top"><p>Universally unique identifier (<code class="literal">java.util.UUID</code>)</p></td></tr></tbody></table>
</div></div><br class="table-break">

</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="property-cardinality"></a>5.3.2.&nbsp;Property Key Cardinality</h3></div></div></div>

<p>Use <code class="literal">cardinality(Cardinality)</code> to define the allowed cardinality of the values associated with the key on any given vertex.</p>
<div class="itemizedlist"><p class="title"><b>Cardinality Settings</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>SINGLE</strong></span>: Allows at most one value per element for such key. In other words, the key&#8594;value mapping is unique for all elements in the graph. The property key <code class="literal">birthDate</code> is an example with SINGLE cardinality since each person has exactly one birth date.
</li><li class="listitem">
<span class="strong"><strong>LIST</strong></span>: Allows an arbitrary number of values per element for such key. In other words, the key is associated with a list of values allowing duplicate values. Assuming we model sensors as vertices in a graph, the property key <code class="literal">sensorReading</code> is an example with LIST cardinality to allow lots of (potentially duplicate) sensor readings to be recorded.
</li><li class="listitem">
<span class="strong"><strong>SET</strong></span>: Allows multiple values but no duplicate values per element for such key. In other words, the key is associated with a set of values. The property key <code class="literal">name</code> has SET cardinality if we want to capture all names of an individual (including nick name, maiden name, etc).
</li></ul></div>

<p>The default cardinality setting is SINGLE.
Note, that property keys used on edges and properties have cardinality SINGLE. Attaching multiple values for a single key on an edge or property is not supported.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>birthDate<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'birthDate'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Long.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.SINGLE<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.SET<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>sensorReading<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'sensorReading'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Double.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.LIST<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_relation_types"></a>5.4.&nbsp;Relation Types</h2></div></div></div>

<p>Edge labels and property keys are jointly referred to as <span class="strong"><strong>relation types</strong></span>. Names of relation types must be unique in the graph which means that property keys and edge labels cannot have the same name. There are methods in the JanusGraph API to query for the existence or retrieve relation types which encompasses both property keys and edge labels.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>if<span class="hl-gremlin-func"> </span><span class="hl-gremlin-func">(</span>mgmt.containsRelationType<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.getRelationTypes<span class="hl-gremlin-func">(</span>EdgeLabel.class<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_defining_vertex_labels"></a>5.5.&nbsp;Defining Vertex Labels</h2></div></div></div>

<p>Like edges, vertices have labels. Unlike edge labels, vertex labels are optional.  Vertex labels are useful to distinguish different types of vertices, e.g. <span class="emphasis"><em>user</em></span> vertices and <span class="emphasis"><em>product</em></span> vertices.</p>
<p>Although labels are optional at the conceptual and data model level, JanusGraph assigns all vertices a label as an internal implementation detail.  Vertices created by the <code class="literal">addVertex</code> methods use JanusGraph&#8217;s default label.</p>
<p>To create a label, call <code class="literal">makeVertexLabel(String).make()</code> on an open graph or management transaction and provide the name of the vertex label as the argument.  Vertex label names must be unique in the graph.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>person<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'person'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Create a labeled vertex</em><span class="hl-gremlin-func">
</span>person<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span>label,<span class="hl-gremlin-func"> </span><span class="hl-string">'person'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Create an unlabeled vertex</em><span class="hl-gremlin-func">
</span>v<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_automatic_schema_maker"></a>5.6.&nbsp;Automatic Schema Maker</h2></div></div></div>

<p>If an edge label, property key, or vertex label has not been defined explicitly, it will be defined implicitly when it is first used during the addition of an edge, vertex or the setting of a property. The <code class="literal">DefaultSchemaMaker</code> configured for the JanusGraph graph defines such types.</p>
<p>By default, implicitly created edge labels have multiplicity MULTI and implicitly created property keys have cardinality SINGLE and data type <code class="literal">Object.class</code>. Users can control automatic schema element creation by implementing and registering their own <code class="literal">DefaultSchemaMaker</code>.</p>
<p>It is strongly encouraged to explicitly define all schema elements and to disable automatic schema creation by setting <code class="literal">schema.default=none</code> in the JanusGraph graph configuration.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_changing_schema_elements"></a>5.7.&nbsp;Changing Schema Elements</h2></div></div></div>

<p>The definition of an edge label, property key, or vertex label cannot be changed once its committed into the graph. However, the names of schema elements can be changed via <code class="literal">JanusGraphManagement.changeName(JanusGraphSchemaElement, String)</code> as shown in the following example where the property key <code class="literal">place</code> is renamed to <code class="literal">location</code>.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>place<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'place'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.changeName<span class="hl-gremlin-func">(</span>place,<span class="hl-gremlin-func"> </span><span class="hl-string">'location'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

<p>Note, that schema name changes may not be immediately visible in currently running transactions and other JanusGraph graph instances in the cluster. While schema name changes are announced to all JanusGraph instances through the storage backend, it may take a while for the schema changes to take effect and it may require a instance restart in the event of certain failure conditions - like network partitions - if they coincide with the rename. Hence, the user must ensure that either of the following holds:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The renamed label or key is not currently in active use (i.e. written or read) and will not be in use until all JanusGraph instances are aware of the name change.
</li><li class="listitem">
Running transactions actively accommodate the brief intermediate period where either the old or new name is valid based on the specific JanusGraph instance and status of the name-change announcement. For instance, that could mean transactions query for both names simultaneously.
</li></ul></div>

<p>Should the need arise to re-define an existing schema type, it is recommended to change the name of this type to a name that is not currently (and will never be) in use. After that, a new label or key can be defined with the original name, thereby effectively replacing the old one.
However, note that this would not affect vertices, edges, or properties previously written with the existing type. Redefining existing graph elements is not supported online and must be accomplished through a batch graph transformation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema-constraints"></a>5.8.&nbsp;Schema Constraints</h2></div></div></div>

<p>The definition of the schema allows users to configure explicit property and connection constraints. Properties can be bound to specific vertex label and/or edge labels. Moreover, connection constraints allow users to explicitly define which two vertex labels can be connected by an edge label. These constraints can be used to ensure that a graph matches a given domain model. For example for the graph of the gods, a <code class="literal">god</code> can be a brother of another <code class="literal">god</code>, but not of a <code class="literal">monster</code> and a <code class="literal">god</code> can have a property <code class="literal">age</code>, but <code class="literal">location</code> can not have a property <code class="literal">age</code>. These constraints are disabled by default.</p>
<p>Enable these schema constraints by setting <code class="literal">schema.constraints=true</code>. This setting depends on the setting <code class="literal">schema.default</code>. If config <code class="literal">schema.default</code> is set to <code class="literal">none</code>, then an <code class="literal">IllegalArgumentException</code> is thrown for schema constraint violations. If <code class="literal">schema.default</code> is not set <code class="literal">none</code>, schema constraints are automatically created, but no exception is thrown.
Activating schema constraints has no impact on the existing data, because these schema constraints are only applied during the insertion process. So reading of data is not affected at all by those constraints.</p>
<p>Multiple properties can be bound to a vertex using <code class="literal">JanusGraphManagement.addProperties(VertexLabel, PropertyKey...)</code>, for example:</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>person<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'person'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.SET<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>birthDate<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'birthDate'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Long.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.SINGLE<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.addProperties<span class="hl-gremlin-func">(</span>person,<span class="hl-gremlin-func"> </span>name,<span class="hl-gremlin-func"> </span>birthDate<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

<p>Multiple properties can be bound to an edge using <code class="literal">JanusGraphManagement.addProperties(EdgeLabel, PropertyKey...)</code>, for example:</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>follow<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'follow'</span><span class="hl-gremlin-func">)</span>.multiplicity<span class="hl-gremlin-func">(</span>MULTI<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.SET<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.addProperties<span class="hl-gremlin-func">(</span>follow,<span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

<p>Connections can be defined using <code class="literal">JanusGraphManagement.addConnection(EdgeLabel, VertexLabel out, VertexLabel in)</code> between an outgoing, an incoming and an edge, for example:</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>person<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'person'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>company<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'company'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>works<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'works'</span><span class="hl-gremlin-func">)</span>.multiplicity<span class="hl-gremlin-func">(</span>MULTI<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.addConnection<span class="hl-gremlin-func">(</span>works,<span class="hl-gremlin-func"> </span>person,<span class="hl-gremlin-func"> </span>company<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

</div>
</div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configuration.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="basics.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="gremlin.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Configuration&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Gremlin Query Language</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="https://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="https://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>