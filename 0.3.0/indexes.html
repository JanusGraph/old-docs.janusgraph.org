<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;Indexing for Better Performance</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="basics.html" title="Part&nbsp;II.&nbsp;JanusGraph Basics"><link rel="prev" href="things-to-consider-in-a-multi-node-janusgraph-cluster.html" title="Chapter&nbsp;10.&nbsp;Things to Consider in a Multi-Node JanusGraph Cluster"><link rel="next" href="tx.html" title="Chapter&nbsp;12.&nbsp;Transactions"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="http://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="http://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="http://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="http://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right dropdown"><a href="https://docs.janusgraph.org/latest/doc-versions.html">Other Doc Versions</a><div class="dropdown-content"><a href="https://docs.janusgraph.org/latest/index.html">Latest</a><a href="https://docs.janusgraph.org/0.3.0/index.html">Version 0.3.0</a><a href="https://docs.janusgraph.org/0.2.1/index.html">Version 0.2.1</a><a href="https://docs.janusgraph.org/0.2.0/index.html">Version 0.2.0</a><a href="https://docs.janusgraph.org/0.1.1/index.html">Version 0.1.1</a><a href="https://docs.janusgraph.org/0.1.0/index.html">Version 0.1.0</a></div></li><li class="header-item-right"><a href="index.html">Documentation (0.3.0)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="basics.html">JanusGraph Basics</a></span> &gt; <span class="breadcrumb-node">Indexing for Better Performance</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="indexes"></a>Chapter&nbsp;11.&nbsp;Indexing for Better Performance</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="indexes.html#graph-indexes">11.1. Graph Index</a></span></dt><dd><dl><dt><span class="section"><a href="indexes.html#_composite_index">11.1.1. Composite Index</a></span></dt><dt><span class="section"><a href="indexes.html#index-mixed">11.1.2. Mixed Index</a></span></dt><dt><span class="section"><a href="indexes.html#_ordering">11.1.3. Ordering</a></span></dt><dt><span class="section"><a href="indexes.html#_label_constraint">11.1.4. Label Constraint</a></span></dt><dt><span class="section"><a href="indexes.html#_composite_versus_mixed_indexes">11.1.5. Composite versus Mixed Indexes</a></span></dt></dl></dd><dt><span class="section"><a href="indexes.html#vertex-indexes">11.2. Vertex-centric Indexes</a></span></dt><dd><dl><dt><span class="section"><a href="indexes.html#_ordered_traversals">11.2.1. Ordered Traversals</a></span></dt></dl></dd></dl></div><p>JanusGraph supports two different kinds of indexing to speed up query processing: <span class="strong"><strong>graph indexes</strong></span> and <span class="strong"><strong>vertex-centric indexes</strong></span>. Most graph queries start the traversal from a list of vertices or edges that are identified by their properties. Graph indexes make these global retrieval operations efficient on large graphs. Vertex-centric indexes speed up the actual traversal through the graph, in particular when traversing through vertices with many incident edges.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="graph-indexes"></a>11.1.&nbsp;Graph Index</h2></div></div></div><p>Graph indexes are global index structures over the entire graph which allow efficient retrieval of vertices or edges by their properties for sufficiently selective conditions. For instance, consider the following queries</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">E(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'reason'</span>,<span class="hl-gremlin-func"> </span>textContains<span class="hl-gremlin-func">(</span><span class="hl-string">'loves'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span></pre><p>The first query asks for all vertices with the name <code class="literal">hercules</code>. The second asks for all edges where the property reason contains the word <code class="literal">loves</code>. Without a graph index answering those queries would require a full scan over all vertices or edges in the graph to find those that match the given condition which is very inefficient and infeasible for huge graphs.</p><p>JanusGraph distinguishes between two types of graph indexes: <span class="strong"><strong>composite</strong></span> and <span class="strong"><strong>mixed</strong></span> indexes. Composite indexes are very fast and efficient but limited to equality lookups for a particular, previously-defined combination of property keys. Mixed indexes can be used for lookups on any combination of indexed keys and support multiple condition predicates in addition to equality depending on the backing index store.</p><p>Both types of indexes are created through the JanusGraph management system and the index builder returned by <code class="literal">JanusGraphManagement.buildIndex(String, Class)</code> where the first argument defines the name of the index and the second argument specifies the type of element to be indexed (e.g. <code class="literal">Vertex.class</code>). The name of a graph index must be unique.
Graph indexes built against newly defined property keys, i.e. property keys that are defined in the same management transaction as the index, are immediately available. Graph indexes built against property keys that are already in use require the execution of a <a class="link" href="index-admin.html#reindex" title="33.1.&nbsp;Reindexing">reindex procedure</a> to ensure that the index contains all previously added elements. Until the reindex procedure has completed, the index will not be available. It is encouraged to define graph indexes in the same transaction as the initial schema.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In the absence of an index, JanusGraph will default to a full graph scan in order to retrieve the desired list of vertices. While this produces the correct result set, the graph scan can be very inefficient and lead to poor overall system performance in a production environment. Enable the <code class="literal">force-index</code> configuration option in production deployments of JanusGraph to prohibit graph scans.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_composite_index"></a>11.1.1.&nbsp;Composite Index</h3></div></div></div><p>Composite indexes retrieve vertices or edges by one or a (fixed) composition of multiple keys.
Consider the following composite index definitions.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>age<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'age'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'byNameComposite'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.buildCompositeIndex<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'byNameAndAgeComposite'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>age<span class="hl-gremlin-func">)</span>.buildCompositeIndex<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'byNameComposite'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'byNameAndAgeComposite'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byNameComposite"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byNameAndAgeComposite"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>First, two property keys <code class="literal">name</code> and <code class="literal">age</code> are already defined. Next, a simple composite index on just the name property key is built. JanusGraph will use this index to answer the following query.</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span></pre><p>The second composite graph index includes both keys. JanusGraph will use this index to answer the following query.</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">30</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span></pre><p>Note, that all keys of a composite graph index must be found in the query&#8217;s equality conditions for this index to be used. For example, the following query cannot be answered with either of the indexes because it only contains a constraint on <code class="literal">age</code> but not <code class="literal">name</code>.</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">30</span><span class="hl-gremlin-func">)</span></pre><p>Also note, that composite graph indexes can only be used for equality constraints like those in the queries above. The following query would be answered with just the simple composite index defined on the <code class="literal">name</code> key because the age constraint is not an equality constraint.</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">20</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span></pre><p>Composite indexes do not require configuration of an external indexing backend and are supported through the primary storage backend. Hence, composite index modifications are persisted through the same transaction as graph modifications which means that those changes are atomic and/or consistent if the underlying storage backend supports atomicity and/or consistency.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>A composite index may comprise just one or multiple keys. A composite index with just one key is sometimes referred to as a key-index.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-unique"></a>11.1.1.1.&nbsp;Index Uniqueness</h4></div></div></div><p>Composite indexes can also be used to enforce property uniqueness in the graph. If a composite graph index is defined as <code class="literal">unique()</code> there can be at most one vertex or edge for any given concatenation of property values associated with the keys of that index.
For instance, to enforce that names are unique across the entire graph the following composite graph index would be defined.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'byNameUnique'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.unique<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.buildCompositeIndex<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'byNameUnique'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byNameUnique"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>To enforce uniqueness against an eventually consistent storage backend, the <a class="link" href="eventual-consistency.html" title="Chapter&nbsp;31.&nbsp;Eventually-Consistent Storage Backends">consistency</a> of the index must be explicitly set to enabling locking.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-mixed"></a>11.1.2.&nbsp;Mixed Index</h3></div></div></div><p>Mixed indexes retrieve vertices or edges by any combination of previously added property keys.
Mixed indexes provide more flexibility than composite indexes and support additional condition predicates beyond equality. On the other hand, mixed indexes are slower for most equality queries than composite indexes.</p><p>Unlike composite indexes, mixed indexes require the configuration of an <a class="link" href="index-backends.html" title="Part&nbsp;IV.&nbsp;Index Backends">indexing backend</a> and use that indexing backend to execute lookup operations. JanusGraph can support multiple indexing backends in a single installation. Each indexing backend must be uniquely identified by name in the JanusGraph configuration which is called the <span class="strong"><strong>indexing backend name</strong></span>.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>age<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'age'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'nameAndAge'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>age<span class="hl-gremlin-func">)</span>.buildMixedIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"search"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'nameAndAge'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"nameAndAge"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>The example above defines a mixed index containing the property keys <code class="literal">name</code> and <code class="literal">age</code>. The definition refers to the indexing backend name <code class="literal">search</code> so that JanusGraph knows which configured indexing backend it should use for this particular index.  The <code class="literal">search</code> parameter specified in the buildMixedIndex call must match the second clause in the JanusGraph configuration definition like this: index.<span class="strong"><strong>search</strong></span>.backend   If the index was named <span class="emphasis"><em>solrsearch</em></span> then the configuration definition would appear like this: index.<span class="strong"><strong>solrsearch</strong></span>.backend.</p><p>The mgmt.buildIndex example specified above uses text search as its default behavior. An index statement that explicitly defines the index as a text index can be written as follows:</p><pre class="programlisting">mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'nameAndAge'</span>,Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name,Mapping.TEXT.getParameter<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>age,Mapping.TEXT.getParameter<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.buildMixedIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"search"</span><span class="hl-gremlin-func">)</span></pre><p>See <a class="xref" href="index-parameters.html" title="Chapter&nbsp;24.&nbsp;Index Parameters and Full-Text Search">Chapter&nbsp;24, <i>Index Parameters and Full-Text Search</i></a> for more information on text and string search options, and see the documentation section specific to the indexing backend in use for more details on how each backend handles text versus string searches.</p><p>While the index definition example looks similar to the composite index above, it provides greater query support and can answer <span class="emphasis"><em>any</em></span> of the following queries.</p><pre class="programlisting">g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span>textContains<span class="hl-gremlin-func">(</span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">20</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span>textContains<span class="hl-gremlin-func">(</span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>lt<span class="hl-gremlin-func">(</span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>outside<span class="hl-gremlin-func">(</span><span class="hl-number">20</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>lt<span class="hl-gremlin-func">(</span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">or(</span>gte<span class="hl-gremlin-func">(</span><span class="hl-number">60</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">or(</span>__.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span>textContains<span class="hl-gremlin-func">(</span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>__.<span class="hl-gremlin-func">has(</span><span class="hl-string">'age'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">20</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span></pre><p>Mixed indexes support full-text search, range search, geo search and others. Refer to <a class="xref" href="search-predicates.html" title="Chapter&nbsp;23.&nbsp;Search Predicates and Data Types">Chapter&nbsp;23, <i>Search Predicates and Data Types</i></a> for a list of predicates supported by a particular indexing backend.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Unlike composite indexes, mixed indexes do not support uniqueness.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_adding_property_keys"></a>11.1.2.1.&nbsp;Adding Property Keys</h4></div></div></div><p>Property keys can be added to an existing mixed index which allows subsequent queries to include this key in the query condition.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>location<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'location'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Geoshape.class<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>nameAndAge<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'nameAndAge'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.addIndexKey<span class="hl-gremlin-func">(</span>nameAndAge,<span class="hl-gremlin-func"> </span>location<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Previously created property keys already have the status ENABLED, but</em><span class="hl-gremlin-func">
</span><em class="hl-comment">//our newly created property key "location" needs to REGISTER so we wait for both statuses</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'nameAndAge'</span><span class="hl-gremlin-func">)</span>.status<span class="hl-gremlin-func">(</span>SchemaStatus.REGISTERED,<span class="hl-gremlin-func"> </span>SchemaStatus.ENABLED<span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"nameAndAge"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>To add a newly defined key, we first retrieve the existing index from the management transaction by its name and then invoke the <code class="literal">addIndexKey</code> method to add the key to this index.</p><p>If the added key is defined in the same management transaction, it will be immediately available for querying. If the property key has already been in use, adding the key requires the execution of a <a class="link" href="index-admin.html#reindex" title="33.1.&nbsp;Reindexing">reindex procedure</a> to ensure that the index contains all previously added elements. Until the reindex procedure has completed, the key will not be available in the mixed index.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_mapping_parameters"></a>11.1.2.2.&nbsp;Mapping Parameters</h4></div></div></div><p>When adding a property key to a mixed index - either through the index builder or the <code class="literal">addIndexKey</code> method - a list of parameters can be optionally specified to adjust how the property value is mapped into the indexing backend. Refer to the <a class="link" href="index-parameters.html#text-search" title="24.1.&nbsp;Full-Text Search">mapping parameters overview</a> for a complete list of parameter types supported by each indexing backend.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ordering"></a>11.1.3.&nbsp;Ordering</h3></div></div></div><p>The order in which the results of a graph query are returned can be defined using the <code class="literal">order().by()</code> directive. The <code class="literal">order().by()</code> method expects two parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The name of the property key by which to order the results. The results will be ordered by the value of the vertices or edges for this property key.</li><li class="listitem">The sort order: either increasing <code class="literal">incr</code> or decreasing <code class="literal">decr</code></li></ul></div><p>For example, the query <code class="literal">g.V().has('name', textContains('hercules')).order().by('age', decr).limit(10)</code> retrieves the ten oldest individuals with <span class="emphasis"><em>hercules</em></span> in their name.</p><p>When using <code class="literal">order().by()</code> it is important to note that:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Composite graph indexes do not natively support ordering search results. All results will be retrieved and then sorted in-memory. For large result sets, this can be very expensive.</li><li class="listitem">Mixed indexes support ordering natively and efficiently. However, the property key used in the order().by() method must have been previously added to the mixed indexed for native result ordering support. This is important in cases where the the order().by() key is different from the query keys. If the property key is not part of the index, then sorting requires loading all results into memory.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_label_constraint"></a>11.1.4.&nbsp;Label Constraint</h3></div></div></div><p>In many cases it is desirable to only index vertices or edges with a particular label. For instance, one may want to index only gods by their name and not every single vertex that has a name property.
When defining an index it is possible to restrict the index to a particular vertex or edge label using the <code class="literal">indexOnly</code> method of the index builder. The following creates a composite index for the property key <code class="literal">name</code> that indexes only vertices labeled <code class="literal">god</code>.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>god<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'god'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'byNameAndLabel'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.indexOnly<span class="hl-gremlin-func">(</span>god<span class="hl-gremlin-func">)</span>.buildCompositeIndex<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'byNameAndLabel'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byNameAndLabel"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Label restrictions similarly apply to mixed indexes. When a composite index with label restriction is defined as unique, the uniqueness constraint only applies to properties on vertices or edges for the specified label.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_composite_versus_mixed_indexes"></a>11.1.5.&nbsp;Composite versus Mixed Indexes</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">Use a composite index for exact match index retrievals. Composite indexes do not require configuring or operating an external index system and are often significantly faster than mixed indexes.</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">As an exception, use a mixed index for exact matches when the number of distinct values for query constraint is relatively small or if one value is expected to be associated with many elements in the graph (i.e. in case of low selectivity).</li></ol></div></li><li class="listitem">Use a mixed indexes for numeric range, full-text or geo-spatial indexing. Also, using a mixed index can speed up the order().by() queries.</li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="vertex-indexes"></a>11.2.&nbsp;Vertex-centric Indexes</h2></div></div></div><p>Vertex-centric indexes are local index structures built individually per vertex. In large graphs vertices can have thousands of incident edges. Traversing through those vertices can be very slow because a large subset of the incident edges has to be retrieved and then filtered in memory to match the conditions of the traversal. Vertex-centric indexes can speed up such traversals by using localized index structures to retrieve only those edges that need to be traversed.</p><p>Suppose that Hercules battled hundreds of monsters in addition to the three captured in the introductory <a class="link" href="getting-started.html" title="Chapter&nbsp;3.&nbsp;Getting Started">Graph of the Gods</a>. Without a vertex-centric index, a query asking for those monsters battled between time point <code class="literal">10</code> and <code class="literal">20</code> would require retrieving all <code class="literal">battled</code> edges even though there are only a handful of matching edges.</p><pre class="programlisting">h<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'time'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">10</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">20</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">inV(</span><span class="hl-gremlin-func">)</span></pre><p>Building a vertex-centric index by time speeds up such traversal queries.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>time<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'time'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>battled<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildEdgeIndex<span class="hl-gremlin-func">(</span>battled,<span class="hl-gremlin-func"> </span><span class="hl-string">'battlesByTime'</span>,<span class="hl-gremlin-func"> </span>Direction.BOTH,<span class="hl-gremlin-func"> </span>Order.decr,<span class="hl-gremlin-func"> </span>time<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'battlesByTime'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"battlesByTime"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>This example builds a vertex-centric index which indexes <code class="literal">battled</code> edges in both direction by time in decreasing order.
A vertex-centric index is built against a particular edge label which is the first argument to the index construction method <code class="literal">JanusGraphManagement.buildEdgeIndex()</code>. The index only applies to edges of this label - <code class="literal">battled</code> in the example above. The second argument is a unique name for the index. The third argument is the edge direction in which the index is built. The index will only apply to traversals along edges in this direction. In this example, the vertex-centric index is built in both direction which means that time restricted traversals along <code class="literal">battled</code> edges can be served by this index in both the <code class="literal">IN</code> and <code class="literal">OUT</code> direction. JanusGraph will maintain a vertex-centric index on both the in- and out-vertex of <code class="literal">battled</code> edges. Alternatively, one could define the index to apply to the <code class="literal">OUT</code> direction only which would speed up traversals from Hercules to the monsters but not in the reverse direction. This would only require maintaining one index and hence half the index maintenance and storage cost.
The last two arguments are the sort order of the index and a list of property keys to index by. The sort order is optional and defaults to ascending order (i.e. <code class="literal">Order.ASC</code>). The list of property keys must be non-empty and defines the keys by which to index the edges of the given label. A vertex-centric index can be defined with multiple keys.</p><pre class="programlisting">graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Never create new indexes while a transaction is active</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>time<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'time'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>rating<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'rating'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Double.class<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>battled<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.buildEdgeIndex<span class="hl-gremlin-func">(</span>battled,<span class="hl-gremlin-func"> </span><span class="hl-string">'battlesByRatingAndTime'</span>,<span class="hl-gremlin-func"> </span>Direction.OUT,<span class="hl-gremlin-func"> </span>Order.decr,<span class="hl-gremlin-func"> </span>rating,<span class="hl-gremlin-func"> </span>time<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Wait for the index to become available</em><span class="hl-gremlin-func">
</span>ManagementSystem.awaitRelationIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'battlesByRatingAndTime'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Reindex the existing data</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getRelationIndex<span class="hl-gremlin-func">(</span>battled,<span class="hl-gremlin-func"> </span><span class="hl-string">'battlesByRatingAndTime'</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>This example extends the schema by a <code class="literal">rating</code> property on <code class="literal">battled</code> edges and builds a vertex-centric index which indexes <code class="literal">battled</code> edges in the out-going direction by rating and time in decreasing order. Note, that the order in which the property keys are specified is important because vertex-centric indexes are prefix indexes. This means, that <code class="literal">battled</code> edges are indexed by <code class="literal">rating</code> <span class="emphasis"><em>first</em></span> and <code class="literal">time</code> <span class="emphasis"><em>second</em></span>.</p><pre class="programlisting">h<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.property<span class="hl-gremlin-func">(</span><span class="hl-string">'rating'</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">5.0</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Add some rating properties</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'rating'</span>,<span class="hl-gremlin-func"> </span>gt<span class="hl-gremlin-func">(</span><span class="hl-number">3.0</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">inV(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'rating'</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">5.0</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'time'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">10</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">inV(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'time'</span>,<span class="hl-gremlin-func"> </span>inside<span class="hl-gremlin-func">(</span><span class="hl-number">10</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">50</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">inV(</span><span class="hl-gremlin-func">)</span></pre><p>Hence, the <code class="literal">battlesByRatingAndTime</code> index can speed up the first two but not the third query.</p><p>Multiple vertex-centric indexes can be built for the same edge label in order to support different constraint traversals. JanusGraph&#8217;s query optimizer attempts to pick the most efficient index for any given traversal. Vertex-centric indexes only support equality and range/interval constraints.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The property keys used in a vertex-centric index must have an explicitly defined data type (i.e. <span class="emphasis"><em>not</em></span> <code class="literal">Object.class</code>) which supports a native sort order. This means not only that they must implement <code class="literal">Comparable</code> but that their serializer must impement <code class="literal">OrderPreservingSerializer</code>. The types that are currently supported are <code class="literal">Boolean</code>, <code class="literal">UUID</code>, <code class="literal">Byte</code>, <code class="literal">Float</code>, <code class="literal">Long</code>, <code class="literal">String</code>, <code class="literal">Integer</code>, <code class="literal">Date</code>, <code class="literal">Double</code>, <code class="literal">Character</code>, and <code class="literal">Short</code></p></td></tr></table></div><p>If the vertex-centric index is built against an edge label that is defined in the same management transaction, the index will be immediately available for querying. If the edge label has already been in use, building a vertex-centric index against it requires the execution of a <a class="link" href="index-admin.html#reindex" title="33.1.&nbsp;Reindexing">reindex procedure</a> to ensure that the index contains all previously added edges. Until the reindex procedure has completed, the index will not be available.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>JanusGraph automatically builds vertex-centric indexes per edge label and property key. That means, even with thousands of incident <code class="literal">battled</code> edges, queries like <code class="literal">g.V(h).out('mother')</code> or <code class="literal">g.V(h).values('age')</code> are efficiently answered by the local index.</p></td></tr></table></div><p>Vertex-centric indexes cannot speed up unconstrained traversals which require traversing through all incident edges of a particular label. Those traversals will become slower as the number of incident edges increases. Often, such traversals can be rewritten as constrained traversals that can utilize a vertex-centric index to ensure acceptable performance at scale.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ordered_traversals"></a>11.2.1.&nbsp;Ordered Traversals</h3></div></div></div><p>The following queries specify an order in which the incident edges are to be traversed. Use the <code class="literal">localLimit</code> command to retrieve a subset of the edges (in a given order) for EACH vertex that is traversed.</p><pre class="programlisting">h<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g..<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'hercules'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.local<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">order(</span><span class="hl-gremlin-func">)</span>.by<span class="hl-gremlin-func">(</span><span class="hl-string">'time'</span>,<span class="hl-gremlin-func"> </span>decr<span class="hl-gremlin-func">)</span>.limit<span class="hl-gremlin-func">(</span><span class="hl-number">10</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">inV(</span><span class="hl-gremlin-func">)</span>.values<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>h<span class="hl-gremlin-func">)</span>.local<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">outE(</span><span class="hl-string">'battled'</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">'rating'</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">5.0</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">order(</span><span class="hl-gremlin-func">)</span>.by<span class="hl-gremlin-func">(</span><span class="hl-string">'time'</span>,<span class="hl-gremlin-func"> </span>decr<span class="hl-gremlin-func">)</span>.limit<span class="hl-gremlin-func">(</span><span class="hl-number">10</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span>.values<span class="hl-gremlin-func">(</span><span class="hl-string">'place'</span><span class="hl-gremlin-func">)</span></pre><p>The first query asks for the names of the 10 most recently battled monsters by Hercules. The second query asks for the places of the 10 most recent battles of Hercules that are rated 5 stars. In both cases, the query is constrained by an order on a property key with a limit on the number of elements to be returned.</p><p>Such queries can also be efficiently answered by vertex-centric indexes if the order key matches the key of the index and the requested order (i.e. increasing or decreasing) is the same as the one defined for the index. The <code class="literal">battlesByTime</code> index would be used to answer the first query and <code class="literal">battlesByRatingAndTime</code> applies to the second. Note, that the <code class="literal">battlesByRatingAndTime</code> index cannot be used to answer the first query because an equality constraint on <code class="literal">rating</code> must be present for the second key in the index to be effective.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Ordered vertex queries are a JanusGraph extension to Gremlin which causes the verbose syntax and requires the <code class="literal">_()</code> step to convert the JanusGraph result back into a Gremlin pipeline.</p></td></tr></table></div></div></div></div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="things-to-consider-in-a-multi-node-janusgraph-cluster.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="basics.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="tx.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Things to Consider in a Multi-Node JanusGraph Cluster&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Transactions</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="http://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>