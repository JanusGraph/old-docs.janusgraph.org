<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;10.&nbsp;Transactions</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="basics.html" title="Part&nbsp;II.&nbsp;JanusGraph Basics"><link rel="prev" href="indexes.html" title="Chapter&nbsp;9.&nbsp;Indexing for Better Performance"><link rel="next" href="caching.html" title="Chapter&nbsp;11.&nbsp;JanusGraph Cache"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="http://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="http://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="http://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="http://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Other Versions</a></li><li class="header-item-right"><a href="index.html">Documentation (0.2.0-SNAPSHOT)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="basics.html">JanusGraph Basics</a></span> &gt; <span class="breadcrumb-node">Transactions</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="tx"></a>Chapter&nbsp;10.&nbsp;Transactions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="tx.html#_transaction_handling">10.1. Transaction Handling</a></span></dt><dt><span class="section"><a href="tx.html#_transactional_scope">10.2. Transactional Scope</a></span></dt><dt><span class="section"><a href="tx.html#_transaction_failures">10.3. Transaction Failures</a></span></dt><dt><span class="section"><a href="tx.html#multi-thread-tx">10.4. Multi-Threaded Transactions</a></span></dt><dt><span class="section"><a href="tx.html#_concurrent_algorithms">10.5. Concurrent Algorithms</a></span></dt><dt><span class="section"><a href="tx.html#_nested_transactions">10.6. Nested Transactions</a></span></dt><dt><span class="section"><a href="tx.html#_common_transaction_handling_problems">10.7. Common Transaction Handling Problems</a></span></dt><dt><span class="section"><a href="tx.html#tx-config">10.8. Transaction Configuration</a></span></dt></dl></div><p>Almost all interaction with JanusGraph is associated with a transaction.  JanusGraph transactions are safe for concurrent use by multiple threads.  Methods on a JanusGraph instance like <code class="literal">graph.V(...)</code> and <code class="literal">graph.tx().commit()</code> perform a <code class="literal">ThreadLocal</code> lookup to retrieve or create a transaction associated with the calling thread.  Callers can alternatively forego <code class="literal">ThreadLocal</code> transaction management in favor of calling <code class="literal">graph.tx().createThreadedTx()</code>, which returns a reference to a transaction object with methods to read/write graph data and commit or rollback.</p><p>JanusGraph transactions are not necessarily ACID.  They can be so configured on BerkleyDB, but they are not generally so on Cassandra or HBase, where the underlying storage system does not provide serializable isolation or multi-row atomic writes and the cost of simulating those properties would be substantial.</p><p>This section describes JanusGraph&#8217;s transactional semantics and API.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_transaction_handling"></a>10.1.&nbsp;Transaction Handling</h2></div></div></div><p>Every graph operation in JanusGraph occurs within the context of a transaction. According to the TinkerPop&#8217;s transactional specification, each thread opens its own transaction against the graph database with the first operation (i.e. retrieval or mutation) on the graph:</p><pre class="programlisting">graph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>JanusGraphFactory.open<span class="hl-gremlin-func">(</span><span class="hl-string">"berkeleyje:/tmp/janusgraph"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>juno<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Automatically opens a new transaction</em><span class="hl-gremlin-func">
</span>juno.property<span class="hl-gremlin-func">(</span><span class="hl-string">"name"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"juno"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Commits transaction</em></pre><p>In this example, a local JanusGraph graph database is opened. Adding the vertex "juno" is the first operation (in this thread) which automatically opens a new transaction. All subsequent operations occur in the context of that same transaction until the transaction is explicitly stopped or the graph database is closed.  If transactions are still open when <code class="literal">close()</code> is called, then the behavior of the outstanding transactions is technically undefined.  In practice, any non-thread-bound transactions will usually be effectively rolled back, but the thread-bound transaction belonging to the thread that invoked shutdown will first be committed. Note, that both read and write operations occur within the context of a transaction.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_transactional_scope"></a>10.2.&nbsp;Transactional Scope</h2></div></div></div><p>All graph elements (vertices, edges, and types) are associated with the transactional scope in which they were retrieved or created. Under TinkerPop&#8217;s default transactional semantics, transactions are automatically created with the first operation on the graph and closed explicitly using <code class="literal">commit()</code> or <code class="literal">rollback()</code>. Once the transaction is closed, all graph elements associated with that transaction become stale and unavailable. However, JanusGraph will automatically transition vertices and types into the new transactional scope as shown in this example:</p><pre class="programlisting">graph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>JanusGraphFactory.open<span class="hl-gremlin-func">(</span><span class="hl-string">"berkeleyje:/tmp/janusgraph"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>juno<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Automatically opens a new transaction</em><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Ends transaction</em><span class="hl-gremlin-func">
</span>juno.property<span class="hl-gremlin-func">(</span><span class="hl-string">"name"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"juno"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Vertex is automatically transitioned</em></pre><p>Edges, on the other hand, are not automatically transitioned and cannot be accessed outside their original transaction. They must be explicitly transitioned:</p><pre class="programlisting">e<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>juno.<span class="hl-gremlin-func">addEdge(</span><span class="hl-string">"knows"</span>,<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Ends transaction</em><span class="hl-gremlin-func">
</span>e<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">E(</span>e<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Need to refresh edge</em><span class="hl-gremlin-func">
</span>e.property<span class="hl-gremlin-func">(</span><span class="hl-string">"time"</span>,<span class="hl-gremlin-func"> </span><span class="hl-number">99</span><span class="hl-gremlin-func">)</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_transaction_failures"></a>10.3.&nbsp;Transaction Failures</h2></div></div></div><p>When committing a transaction, JanusGraph will attempt to persist all changes to the storage backend. This might not always be successful due to IO exceptions, network errors, machine crashes or resource unavailability. Hence, transactions can fail. In fact, transactions <span class="strong"><strong>will eventually fail</strong></span> in sufficiently large systems. Therefore, we highly recommend that your code expects and accommodates such failures:</p><pre class="programlisting">try<span class="hl-gremlin-func"> </span>{<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>if<span class="hl-gremlin-func"> </span><span class="hl-gremlin-func">(</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">"name"</span>,<span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func">)</span>.iterat<span class="hl-gremlin-func">or(</span><span class="hl-gremlin-func">)</span>.hasNext<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>throw<span class="hl-gremlin-func"> </span>new<span class="hl-gremlin-func"> </span>IllegalArgumentException<span class="hl-gremlin-func">(</span><span class="hl-string">"Username already taken: "</span><span class="hl-gremlin-func"> </span>+<span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>user<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>user.property<span class="hl-gremlin-func">(</span><span class="hl-string">"name"</span>,<span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>}<span class="hl-gremlin-func"> </span>catch<span class="hl-gremlin-func"> </span><span class="hl-gremlin-func">(</span>Exception<span class="hl-gremlin-func"> </span>e<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span>{<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><em class="hl-comment">//Recover, retry, 	or return error message</em><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>println<span class="hl-gremlin-func">(</span>e.getMessage<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>}</pre><p>The example above demonstrates a simplified user signup implementation where <code class="literal">name</code> is the name of the user who wishes to register. First, it is checked whether a user with that name already exists. If not, a new user vertex is created and the name assigned. Finally, the transaction is committed.</p><p>If the transaction fails, a <code class="literal">JanusGraphException</code> is thrown. There are a variety of reasons why a transaction may fail. JanusGraph differentiates between <span class="emphasis"><em>potentially temporary</em></span> and <span class="emphasis"><em>permanent</em></span> failures.</p><p>Potentially temporary failures are those related to resource unavailability and IO hiccups (e.g. network timeouts). JanusGraph automatically tries to recover from temporary failures by retrying to persist the transactional state after some delay. The number of retry attempts and the retry delay are configurable (see <a class="xref" href="config-ref.html" title="Chapter&nbsp;13.&nbsp;Configuration Reference">Chapter&nbsp;13, <i>Configuration Reference</i></a>).</p><p>Permanent failures can be caused by complete connection loss, hardware failure or lock contention. To understand the cause of lock contention, consider the signup example above and suppose a user tries to signup with username "juno". That username may still be available at the beginning of the transaction but by the time the transaction is committed, another user might have concurrently registered with "juno" as well and that transaction holds the lock on the username therefore causing the other transaction to fail. Depending on the transaction semantics one can recover from a lock contention failure by re-running the entire transaction.</p><p>Permanent exceptions that can fail a transaction include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">PermanentLockingException(<span class="strong"><strong>Local lock contention</strong></span>): Another local thread has already been granted a conflicting lock.</li><li class="listitem">PermanentLockingException(<span class="strong"><strong>Expected value mismatch for X: expected=Y vs actual=Z</strong></span>): The verification that the value read in this transaction is the same as the one in the datastore after applying for the lock failed. In other words, another transaction modified the value after it had been read and modified.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multi-thread-tx"></a>10.4.&nbsp;Multi-Threaded Transactions</h2></div></div></div><p>JanusGraph supports multi-threaded transactions through TinkerPop&#8217;s <a class="link" href="http://tinkerpop.apache.org/docs/3.2.6/reference#_threaded_transactions" target="_top">threaded transactions</a>. Hence, to speed up transaction processing and utilize multi-core architectures multiple threads can run concurrently in a single transaction.</p><p>With TinkerPop&#8217;s default transaction handling, each thread automatically opens its own transaction against the graph database. To open a thread-independent transaction, use the <code class="literal">createThreadedTx()</code> method.</p><pre class="programlisting">threadedGraph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.createThreadedTx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>;<span class="hl-gremlin-func">
</span>threads<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>new<span class="hl-gremlin-func"> </span>Thread[<span class="hl-number">10</span>];<span class="hl-gremlin-func">
</span>f<span class="hl-gremlin-func">or </span><span class="hl-gremlin-func">(</span>int<span class="hl-gremlin-func"> </span>i=<span class="hl-number">0</span>;<span class="hl-gremlin-func"> </span>i&lt;threads.length;<span class="hl-gremlin-func"> </span>i++<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span>{<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>threads[i]=new<span class="hl-gremlin-func"> </span>Thread<span class="hl-gremlin-func">(</span>{<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>println<span class="hl-gremlin-func">(</span><span class="hl-string">"Do something with 'threadedGraph''"</span><span class="hl-gremlin-func">)</span>;<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>}<span class="hl-gremlin-func">)</span>;<span class="hl-gremlin-func">
</span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span><span class="hl-gremlin-func"> </span>threads[i].start<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>;<span class="hl-gremlin-func">
</span>}<span class="hl-gremlin-func">
</span>f<span class="hl-gremlin-func">or </span><span class="hl-gremlin-func">(</span>int<span class="hl-gremlin-func"> </span>i=<span class="hl-number">0</span>;<span class="hl-gremlin-func"> </span>i&lt;threads.length;<span class="hl-gremlin-func"> </span>i++<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span>threads[i].jo<span class="hl-gremlin-func">in(</span><span class="hl-gremlin-func">)</span>;<span class="hl-gremlin-func">
</span>threadedGraph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>;</pre><p>The <code class="literal">createThreadedTx()</code> method returns a new <code class="literal">Graph</code> object that represents this newly opened transaction. The graph object <code class="literal">tx</code> supports all of the methods that the original graph did, but does so without opening new transactions for each thread. This allows us to start multiple threads which all work concurrently in the same transaction and one of which finally commits the transaction when all threads have completed their work.</p><p>JanusGraph relies on optimized concurrent data structures to support hundreds of concurrent threads running efficiently in a single transaction.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_concurrent_algorithms"></a>10.5.&nbsp;Concurrent Algorithms</h2></div></div></div><p>Thread independent transactions started through <code class="literal">createThreadedTx()</code> are particularly useful when implementing concurrent graph algorithms. Most traversal or message-passing (ego-centric) like graph algorithms are <a class="link" href="http://en.wikipedia.org/wiki/Embarrassingly_parallel" target="_top">embarrassingly parallel</a> which means they can be parallelized and executed through multiple threads with little effort. Each of these threads can operate on a single <code class="literal">Graph</code> object returned by <code class="literal">createThreadedTx()</code> without blocking each other.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_nested_transactions"></a>10.6.&nbsp;Nested Transactions</h2></div></div></div><p>Another use case for thread independent transactions is nested transactions that ought to be independent from the surrounding transaction.</p><p>For instance, assume a long running transactional job that has to create a new vertex with a unique name. Since enforcing unique names requires the acquisition of a lock (see <a class="xref" href="eventual-consistency.html" title="Chapter&nbsp;29.&nbsp;Eventually-Consistent Storage Backends">Chapter&nbsp;29, <i>Eventually-Consistent Storage Backends</i></a> for more detail) and since the transaction is running for a long time, lock congestion and expensive transactional failures are likely.</p><pre class="programlisting">v1<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Do many other things</em><span class="hl-gremlin-func">
</span>v2<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v2.property<span class="hl-gremlin-func">(</span><span class="hl-string">"uniqueName"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"foo"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v1.<span class="hl-gremlin-func">addEdge(</span><span class="hl-string">"related"</span>,<span class="hl-gremlin-func"> </span>v2<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Do many other things</em><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// This long-running tx might fail due to contention on its uniqueName lock</em></pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">One way around this is to create the vertex in a short, nested thread-independent transaction as demonstrated by the following pseudo code</span></dt><dd></dd></dl></div><pre class="programlisting">v1<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//Do many other things</em><span class="hl-gremlin-func">
</span>tx<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.createThreadedTx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v2<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>tx.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v2.property<span class="hl-gremlin-func">(</span><span class="hl-string">"uniqueName"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"foo"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>tx.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Any lock contention will be detected here</em><span class="hl-gremlin-func">
</span>v1.<span class="hl-gremlin-func">addEdge(</span><span class="hl-string">"related"</span>,<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">V(</span>v2<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Need to load v2 into outer transaction</em><span class="hl-gremlin-func">
</span><em class="hl-comment">//Do many other things</em><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Can't fail due to uniqueName write lock contention involving v2</em></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_common_transaction_handling_problems"></a>10.7.&nbsp;Common Transaction Handling Problems</h2></div></div></div><p>Transactions are started automatically with the first operation executed against the graph. One does NOT have to start a transaction manually. The method <code class="literal">newTransaction</code> is used to start <a class="link" href="tx.html#multi-thread-tx" title="10.4.&nbsp;Multi-Threaded Transactions">multi-threaded transactions</a> only.</p><p>Transactions are automatically started under the TinkerPop semantics but <span class="strong"><strong>not</strong></span> automatically terminated. Transactions must be terminated manually with <code class="literal">commit()</code> or <code class="literal">rollback()</code>. If a <code class="literal">commit()</code> transactions fails, it should be terminated manually with <code class="literal">rollback()</code> after catching the failure. Manual termination of transactions is necessary because only the user knows the transactional boundary.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">A transaction will attempt to maintain its state from the beginning of the transaction. This might lead to unexpected behavior in multi-threaded applications as illustrated in the following artificial example</span></dt><dd></dd></dl></div><pre class="programlisting">v<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">V(</span><span class="hl-number">4</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Retrieve vertex, first action automatically starts transaction</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>v<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">bothE(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>&gt;&gt;<span class="hl-gremlin-func"> </span>returns<span class="hl-gremlin-func"> </span>nothing,<span class="hl-gremlin-func"> </span>v<span class="hl-gremlin-func"> </span><span class="hl-gremlin-func">has </span>no<span class="hl-gremlin-func"> </span>edges<span class="hl-gremlin-func">
</span><em class="hl-comment">//thread is idle for a few seconds, another thread adds edges to v</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>v<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">bothE(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>&gt;&gt;<span class="hl-gremlin-func"> </span>still<span class="hl-gremlin-func"> </span>returns<span class="hl-gremlin-func"> </span>nothing<span class="hl-gremlin-func"> </span>because<span class="hl-gremlin-func"> </span>the<span class="hl-gremlin-func"> </span>transactional<span class="hl-gremlin-func"> </span>state<span class="hl-gremlin-func"> </span>from<span class="hl-gremlin-func"> </span>the<span class="hl-gremlin-func"> </span>beginning<span class="hl-gremlin-func"> </span>is<span class="hl-gremlin-func"> </span>maintained</pre><p>Such unexpected behavior is likely to occur in client-server applications where the server maintains multiple threads to answer client requests. It is therefore important to terminate the transaction after a unit of work (e.g. code snippet, query, etc). So, the example above should be:</p><pre class="programlisting">v<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>g.<span class="hl-gremlin-func">V(</span><span class="hl-number">4</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">next(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Retrieve vertex, first action automatically starts transaction</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>v<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">bothE(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><em class="hl-comment">//thread is idle for a few seconds, another thread adds edges to v</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span>v<span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">bothE(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>&gt;&gt;<span class="hl-gremlin-func"> </span>returns<span class="hl-gremlin-func"> </span>the<span class="hl-gremlin-func"> </span>newly<span class="hl-gremlin-func"> </span>added<span class="hl-gremlin-func"> </span>edge<span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>When using multi-threaded transactions via <code class="literal">newTransaction</code> all vertices and edges retrieved or created in the scope of that transaction are <span class="strong"><strong>not</strong></span> available outside the scope of that transaction. Accessing such elements after the transaction has been closed will result in an exception. As demonstrated in the example above, such elements have to be explicitly refreshed in the new transaction using <code class="literal">g.V(existingVertex)</code> or <code class="literal">g.E(existingEdge)</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tx-config"></a>10.8.&nbsp;Transaction Configuration</h2></div></div></div><p>JanusGraph&#8217;s <code class="literal">JanusGraph.buildTransaction()</code> method gives the user the ability to configure and start a new <a class="link" href="tx.html#multi-thread-tx" title="10.4.&nbsp;Multi-Threaded Transactions">multi-threaded transaction</a> against a <code class="literal">JanusGraph</code>. Hence, it is identical to <code class="literal">JanusGraph.newTransaction()</code> with additional configuration options.</p><p><code class="literal">buildTransaction()</code> returns a <code class="literal">TransactionBuilder</code> which allows the following aspects of a transaction to be configured:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">readOnly()</code> - makes the transaction read-only and any attempt to modify the graph will result in an exception.</li><li class="listitem"><code class="literal">enableBatchLoading()</code> - enables batch-loading for an individual transaction. This setting results in similar efficiencies as the graph-wide setting <code class="literal">storage.batch-loading</code> due to the disabling of consistency checks and other optimizations. Unlike <code class="literal">storage.batch-loading</code> this option will not change the behavior of the storage backend.</li><li class="listitem"><code class="literal">setTimestamp(long)</code> - Sets the timestamp for this transaction as communicated to the storage backend for persistence. Depending on the storage backend, this setting may be ignored. For eventually consistent backends, this is the timestamp used to resolve write conflicts. If this setting is not explicitly specified, JanusGraph uses the current time.</li><li class="listitem"><code class="literal">setVertexCacheSize(long size)</code> - The number of vertices this transaction caches in memory. The larger this number, the more memory a transaction can potentially consume. If this number is too small, a transaction might have to re-fetch data which causes delays in particular for long running transactions.</li><li class="listitem"><code class="literal">checkExternalVertexExistence(boolean)</code> - Whether this transaction should verify the existence of vertices for user provided vertex ids. Such checks requires access to the database which takes time. The existence check should only be disabled if the user is absolutely sure that the vertex must exist - otherwise data corruption can ensue.</li><li class="listitem"><code class="literal">checkInternalVertexExistence(boolean)</code> - Whether this transaction should double-check the existence of vertices during query execution. This can be useful to avoid <span class="strong"><strong>phantom vertices</strong></span> on eventually consistent storage backends. Disabled by default. Enabling this setting can slow down query processing.</li><li class="listitem"><code class="literal">consistencyChecks(boolean)</code> - Whether JanusGraph should enforce schema level consistency constraints (e.g. multiplicity constraints). Disabling consistency checks leads to better performance but requires that the user ensures consistency confirmation at the application level to avoid inconsistencies. USE WITH GREAT CARE!</li></ul></div><p>Once, the desired configuration options have been specified, the new transaction is started via <code class="literal">start()</code> which returns a <code class="literal">JanusGraphTransaction</code>.</p></div></div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="basics.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="caching.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;9.&nbsp;Indexing for Better Performance&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;11.&nbsp;JanusGraph Cache</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="http://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>