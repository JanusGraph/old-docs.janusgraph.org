<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;30.&nbsp;Advanced Schema</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="advanced.html" title="Part&nbsp;V.&nbsp;Advanced Topics"><link rel="prev" href="advanced.html" title="Part&nbsp;V.&nbsp;Advanced Topics"><link rel="next" href="eventual-consistency.html" title="Chapter&nbsp;31.&nbsp;Eventually-Consistent Storage Backends"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="http://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="http://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="http://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="http://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right dropdown"><a href="https://docs.janusgraph.org/latest/doc-versions.html">Other Doc Versions</a><div class="dropdown-content"><a href="https://docs.janusgraph.org/latest/index.html">Latest</a><a href="https://docs.janusgraph.org/0.3.1/index.html">Version 0.3.1</a><a href="https://docs.janusgraph.org/0.3.0/index.html">Version 0.3.0</a><a href="https://docs.janusgraph.org/0.2.2/index.html">Version 0.2.2</a><a href="https://docs.janusgraph.org/0.2.1/index.html">Version 0.2.1</a><a href="https://docs.janusgraph.org/0.2.0/index.html">Version 0.2.0</a><a href="https://docs.janusgraph.org/0.1.1/index.html">Version 0.1.1</a><a href="https://docs.janusgraph.org/0.1.0/index.html">Version 0.1.0</a></div></li><li class="header-item-right"><a href="index.html">Documentation (0.3.1)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="advanced.html">Advanced Topics</a></span> &gt; <span class="breadcrumb-node">Advanced Schema</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="advanced-schema"></a>Chapter&nbsp;30.&nbsp;Advanced Schema</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="advanced-schema.html#_static_vertices">30.1. Static Vertices</a></span></dt><dt><span class="section"><a href="advanced-schema.html#_edge_and_vertex_ttl">30.2. Edge and Vertex TTL</a></span></dt><dd><dl><dt><span class="section"><a href="advanced-schema.html#_edge_ttl">30.2.1. Edge TTL</a></span></dt><dt><span class="section"><a href="advanced-schema.html#_property_ttl">30.2.2. Property TTL</a></span></dt><dt><span class="section"><a href="advanced-schema.html#_vertex_ttl">30.2.3. Vertex TTL</a></span></dt></dl></dd><dt><span class="section"><a href="advanced-schema.html#_multi_properties">30.3. Multi-Properties</a></span></dt><dt><span class="section"><a href="advanced-schema.html#_unidirected_edges">30.4. Unidirected Edges</a></span></dt></dl></div><p>This page describes some of the advanced schema definition options that JanusGraph provides. For general information on JanusGraph&#8217;s schema and how to define it, refer to <a class="xref" href="schema.html" title="Chapter&nbsp;5.&nbsp;Schema and Data Modeling">Chapter&nbsp;5, <i>Schema and Data Modeling</i></a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_static_vertices"></a>30.1.&nbsp;Static Vertices</h2></div></div></div><p>Vertex labels can be defined as <span class="strong"><strong>static</strong></span> which means that vertices with that label cannot be modified outside the transaction in which they were created.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>tweet<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'tweet'</span><span class="hl-gremlin-func">)</span>.setStatic<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Static vertex labels are a method of controlling the data lifecycle and useful when loading data into the graph that should not be modified after its creation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_edge_and_vertex_ttl"></a>30.2.&nbsp;Edge and Vertex TTL</h2></div></div></div><p>Edge and vertex labels can be configured with a <span class="strong"><strong>time-to-live (TTL)</strong></span>. Edges and vertices with such labels will automatically be removed from the graph when the configured TTL has passed after their initial creation. TTL configuration is useful when loading a large amount of data into the graph that is only of temporary use. Defining a TTL removes the need for manual clean up and handles the removal very efficiently. For example, it would make sense to TTL event edges such as user-page visits when those are summarized after a certain period of time or simply no longer needed for analytics or operational query processing.</p><p>The following storage backends support edge and vertex TTL.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Cassandra</li><li class="listitem">HBase</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_edge_ttl"></a>30.2.1.&nbsp;Edge TTL</h3></div></div></div><p>Edge TTL is defined on a per-edge label basis, meaning that all edges of that label have the same time-to-live. Note that the backend must support cell level TTL. Currently only Cassandra and HBase support this.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>visits<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'visits'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.setTTL<span class="hl-gremlin-func">(</span>visits,<span class="hl-gremlin-func"> </span>Duration.ofDays<span class="hl-gremlin-func">(</span><span class="hl-number">7</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Note, that modifying an edge resets the TTL for that edge. Also note, that the TTL of an edge label can be modified but it might take some time for this change to propagate to all running JanusGraph instances which means that two different TTLs can be temporarily in use for the same label.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_property_ttl"></a>30.2.2.&nbsp;Property TTL</h3></div></div></div><p>Property TTL is very similar to edge TTL and defined on a per-property key basis, meaning that all properties of that key have the same time-to-live. Note that the backend must support cell level TTL. Currently only Cassandra and HBase support this.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>sens<span class="hl-gremlin-func">or </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'sensor'</span><span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.LIST<span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>Double.class<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.setTTL<span class="hl-gremlin-func">(</span>sensor,<span class="hl-gremlin-func"> </span>Duration.ofDays<span class="hl-gremlin-func">(</span><span class="hl-number">21</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>As with edge TTL, modifying an existing property resets the TTL for that property and modifying the TTL for a property key might not immediately take effect.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_vertex_ttl"></a>30.2.3.&nbsp;Vertex TTL</h3></div></div></div><p>Vertex TTL is defined on a per-vertex label basis, meaning that all vertices of that label have the same time-to-live. The configured TTL applies to the vertex, its properties, and all incident edges to ensure that the entire vertex is removed from the graph. For this reason, a vertex label must be defined as <span class="emphasis"><em>static</em></span> before a TTL can be set to rule out any modifications that would invalidate the vertex TTL. Vertex TTL only applies to static vertex labels. Note that the backend must support store level TTL. Currently only Cassandra and HBase support this.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>tweet<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'tweet'</span><span class="hl-gremlin-func">)</span>.setStatic<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.setTTL<span class="hl-gremlin-func">(</span>tweet,<span class="hl-gremlin-func"> </span>Duration.ofHours<span class="hl-gremlin-func">(</span><span class="hl-number">36</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Note, that the TTL of a vertex label can be modified but it might take some time for this change to propagate to all running JanusGraph instances which means that two different TTLs can be temporarily in use for the same label.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_multi_properties"></a>30.3.&nbsp;Multi-Properties</h2></div></div></div><p>As discussed in <a class="xref" href="schema.html" title="Chapter&nbsp;5.&nbsp;Schema and Data Modeling">Chapter&nbsp;5, <i>Schema and Data Modeling</i></a>, JanusGraph supports property keys with SET and LIST cardinality. Hence, JanusGraph supports multiple properties with the same key on a single vertex. Furthermore, JanusGraph treats properties similarly to edges in that single-valued property annotations are allowed on properties as shown in the following example.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.cardinality<span class="hl-gremlin-func">(</span>Cardinality.LIST<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>p1<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>v.property<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'Dan LaRocque'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>p1.property<span class="hl-gremlin-func">(</span><span class="hl-string">'source'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'web'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>p2<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>v.property<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'dalaro'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>p2.property<span class="hl-gremlin-func">(</span><span class="hl-string">'source'</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">'github'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>v.properties<span class="hl-gremlin-func">(</span><span class="hl-string">'name'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-repl-result">==&gt;</span><span class="hl-gremlin-func"> </span>Iterable<span class="hl-gremlin-func"> </span>over<span class="hl-gremlin-func"> </span>all<span class="hl-gremlin-func"> </span>name<span class="hl-gremlin-func"> </span>properties</pre><p>These features are useful in a number of applications such as those where attaching provenance information (e.g. who added a property, when and from where?) to properties is necessary. Support for higher cardinality properties and property annotations on properties is also useful in high-concurrency, scale-out design patterns as described in <a class="xref" href="eventual-consistency.html" title="Chapter&nbsp;31.&nbsp;Eventually-Consistent Storage Backends">Chapter&nbsp;31, <i>Eventually-Consistent Storage Backends</i></a>._</p><p>Vertex-centric indexes and global graph indexes are supported for properties in the same manner as they are supported for edges. Refer to <a class="xref" href="indexes.html" title="Chapter&nbsp;11.&nbsp;Indexing for Better Performance">Chapter&nbsp;11, <i>Indexing for Better Performance</i></a> for information on defining these indexes for edges and use the corresponding API methods to define the same indexes for properties.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_unidirected_edges"></a>30.4.&nbsp;Unidirected Edges</h2></div></div></div><p>Unidirected edges are edges that can only be traversed in the out-going direction. Unidirected edges have a lower storage footprint but are limited in the types of traversals they support. Unidirected edges are conceptually similar to hyperlinks in the world-wide-web in the sense that the out-vertex can traverse through the edge, but the in-vertex is unaware of its existence.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'author'</span><span class="hl-gremlin-func">)</span>.unidirected<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Note, that unidirected edges do not get automatically deleted when their in-vertices are deleted. The user must ensure that such inconsistencies do not arise or resolve them at query time by explicitly checking vertex existence in a transaction. See the discussion in <a class="xref" href="eventual-consistency.html#ghost-vertices" title="31.2.2.&nbsp;Ghost Vertices">Section&nbsp;31.2.2, &#8220;Ghost Vertices&#8221;</a> for more information.</p></div></div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="advanced.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="eventual-consistency.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;V.&nbsp;Advanced Topics&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;31.&nbsp;Eventually-Consistent Storage Backends</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="http://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>