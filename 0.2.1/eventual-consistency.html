<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;29.&nbsp;Eventually-Consistent Storage Backends</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="advanced.html" title="Part&nbsp;V.&nbsp;Advanced Topics"><link rel="prev" href="advanced-schema.html" title="Chapter&nbsp;28.&nbsp;Advanced Schema"><link rel="next" href="failure-recovery.html" title="Chapter&nbsp;30.&nbsp;Failure &amp; Recovery"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="http://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="http://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="http://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="http://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Other Versions</a></li><li class="header-item-right"><a href="index.html">Documentation (0.2.1)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="advanced.html">Advanced Topics</a></span> &gt; <span class="breadcrumb-node">Eventually-Consistent Storage Backends</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="eventual-consistency"></a>Chapter&nbsp;29.&nbsp;Eventually-Consistent Storage Backends</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="eventual-consistency.html#_data_consistency">29.1. Data Consistency</a></span></dt><dd><dl><dt><span class="section"><a href="eventual-consistency.html#_data_consistency_without_locks">29.1.1. Data Consistency without Locks</a></span></dt></dl></dd><dt><span class="section"><a href="eventual-consistency.html#_data_inconsistency">29.2. Data Inconsistency</a></span></dt><dd><dl><dt><span class="section"><a href="eventual-consistency.html#_temporary_inconsistency">29.2.1. Temporary Inconsistency</a></span></dt><dt><span class="section"><a href="eventual-consistency.html#ghost-vertices">29.2.2. Ghost Vertices</a></span></dt></dl></dd></dl></div><p>When running JanusGraph against an eventually consistent storage backend special JanusGraph features must be used to ensure data consistency and special considerations must be made regarding data degradation.</p><p>This page summarizes some of the aspects to consider when running JanusGraph on top of an eventually consistent storage backend like Apache Cassandra or Apache HBase.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_data_consistency"></a>29.1.&nbsp;Data Consistency</h2></div></div></div><p>On eventually consistent storage backends, JanusGraph must obtain locks in order to ensure consistency because the underlying storage backend does not provide transactional isolation. In the interest of efficiency, JanusGraph does not use locking by default. Hence, the user has to decide for each schema element that defines a consistency constraint whether or not to use locking. Use <code class="literal">JanusGraphManagement.setConsistency(element, ConsistencyModifier.LOCK)</code> to explicitly enable locking on a schema element as shown in the following examples.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>name<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">'consistentName'</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>index<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'byConsistentName'</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>name<span class="hl-gremlin-func">)</span>.unique<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.buildCompositeIndex<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.setConsistency<span class="hl-gremlin-func">(</span>name,<span class="hl-gremlin-func"> </span>ConsistencyModifier.LOCK<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Ensures only one name per vertex</em><span class="hl-gremlin-func">
</span>mgmt.setConsistency<span class="hl-gremlin-func">(</span>index,<span class="hl-gremlin-func"> </span>ConsistencyModifier.LOCK<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func"> </span><em class="hl-comment">// Ensures name uniqueness in the graph</em><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>When updating an element that is guarded by a uniqueness constraint, JanusGraph uses the following protocol at the end of a transaction when calling <code class="literal">tx.commit()</code>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Acquire a lock on all elements that have a consistency constraint</li><li class="listitem">Re-read those elements from the storage backend and verify that they match the state of the element in the current transaction prior to modification. If not, the element was concurrently modified and a PermanentLocking exception is thrown.</li><li class="listitem">Persist the state of the transaction against the storage backend.</li><li class="listitem">Release all locks.</li></ol></div><p>This is a brief description of the locking protocol which leaves out optimizations (e.g. local conflict detection) and detection of failure scenarios (e.g. expired locks).</p><p>The actual lock application mechanism is abstracted such that JanusGraph can use multiple implementations of a locking provider. Currently, two locking providers are supported in the JanusGraph distribution:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A locking implementation based on key-consistent read and write operations that is agnostic to the underlying storage backend as long as it supports key-consistent operations (which includes Cassandra and HBase). This is the default implementation and uses timestamp based lock applications to determine which transaction holds the lock.</li><li class="listitem">A Cassandra specific locking implementation based on the Astyanax locking recipe.</li></ol></div><p>Both locking providers require that clocks are synchronized across all machines in the cluster.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>The locking implementation is not robust against all failure
scenarios. For instance, when a Cassandra cluster drops below quorum,
consistency is no longer ensured. Hence, it is suggested to use
locking-based consistency constraints sparingly with eventually
consistent storage backends.  For use cases that require strict and or
frequent consistency constraint enforcement, it is suggested to use a
storage backend that provides transactional isolation.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_data_consistency_without_locks"></a>29.1.1.&nbsp;Data Consistency without Locks</h3></div></div></div><p>Because of the additional steps required to acquire a lock when committing a modifying transaction, locking is a fairly expensive way to ensure consistency and can lead to deadlock when very many concurrent transactions try to modify the same elements in the graph. Hence, locking should be used in situations where consistency is more important than write latency and the number of conflicting transactions is small.</p><p>In other situations, it may be better to allow conflicting transactions to proceed and to resolve inconsistencies at read time. This is a design pattern commonly employed in large scale data systems and most effective when the actual likelihood of conflict is small. Hence, write transactions don&#8217;t incur additional overhead and any (unlikely) conflict that does occur is detected and resolved at read time and later cleaned up. JanusGraph makes it easy to use this strategy through the following features.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_forking_edges"></a>29.1.1.1.&nbsp;Forking Edges</h4></div></div></div><p>Because edge are stored as single records in the underlying storage backend, concurrently modifying a single edge would lead to conflict. Instead of locking, an edge label can be configured to use <code class="literal">ConsistencyModifier.FORK</code>. The following example creates a new edge label <code class="literal">related</code> and defines its consistency to FORK.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>related<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makeEdgeLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'related'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.setConsistency<span class="hl-gremlin-func">(</span>related,<span class="hl-gremlin-func"> </span>ConsistencyModifier.FORK<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>When modifying an edge whose label is configured to FORK the edge is deleted and the modified edge is added as a new one. Hence, if two concurrent transactions modify the same edge, two modified copies of the edge will exist upon commit which can be resolved during querying traversals if needed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Edge forking only applies to MULTI edges. Edge labels with a multiplicity constraint cannot use this strategy since a constraint is built into the edge label definition that requires an explicit lock or use the conflict resolution mechanism of the underlying storage backend.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_multi_properties_2"></a>29.1.1.2.&nbsp;Multi-Properties</h4></div></div></div><p>Modifying single valued properties on vertices concurrently can result in a conflict. Similarly to edges, one can allow an arbitrary number of properties on a vertex for a particular property key defined with cardinality LIST and FORK on modification. Hence, instead of conflict one reads multiple properties. Since JanusGraph allows properties on properties, provenance information like <code class="literal">author</code> can be added to the properties to facilitate resolution at read time.</p><p>See <a class="link" href="schema.html#property-cardinality" title="5.2.2.&nbsp;Property Key Cardinality">multi-properties</a> to learn how to define those.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_data_inconsistency"></a>29.2.&nbsp;Data Inconsistency</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_temporary_inconsistency"></a>29.2.1.&nbsp;Temporary Inconsistency</h3></div></div></div><p>On eventually consistent storage backends, writes may not be immediately visible to the entire cluster causing temporary inconsistencies in the graph. This is an inherent property of eventual consistency, in the sense, that accepted updates must be propagated to other instances in the cluster and no guarantees are made with respect to read atomicity in the interest of performance.</p><p>From JanusGraph&#8217;s perspective, eventual consistency might cause the following temporary graph inconsistencies in addition the general inconsistency that some parts of a transaction are visible while others aren&#8217;t yet.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>Stale Index entries</strong></span></span></dt><dd>Index entries might point to nonexistent
vertices or edges. Similarly, a vertex or edge appears in the graph but is not yet indexed and hence ignored by global graph queries.</dd><dt><span class="term"><span class="strong"><strong>Half-Edges</strong></span></span></dt><dd>Only one direction of an edge gets persisted or deleted
which might lead to the edge not being or incorrectly being retrieved.</dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In order to avoid that write failures result in permanent inconsistencies in the graph it is recommended to use storage backends that support batch write atomicity and to ensure that write atomicity is enabled.  To get the benefit of write atomicity, the number modifications made in a single transaction must be smaller than the configured <code class="literal">buffer-size</code> option documented in <a class="xref" href="config-ref.html" title="Chapter&nbsp;13.&nbsp;Configuration Reference">Chapter&nbsp;13, <i>Configuration Reference</i></a>. The buffer size defines the maximum number of modifications that JanusGraph will persist in a single batch. If a transaction has more modifications, the persistence will be split into multiple batches which are persisted individually which is useful for batch loading but invalidates write atomicity.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ghost-vertices"></a>29.2.2.&nbsp;Ghost Vertices</h3></div></div></div><p>A permanent inconsistency that can arise when operating JanusGraph on eventually consistent storage backend is the phenomena of <span class="strong"><strong>ghost vertices</strong></span>. If a vertex gets deleted while it is concurrently
being modified, the vertex might re-appear as a <span class="emphasis"><em>ghost</em></span>.</p><p>The following strategies can be used to mitigate this issue:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>Existence checks</strong></span></span></dt><dd>Configure transactions to (double) check for the
existence of vertices prior to returning them. Please see
<a class="xref" href="tx.html#tx-config" title="10.8.&nbsp;Transaction Configuration">Section&nbsp;10.8, &#8220;Transaction Configuration&#8221;</a> for more information and note that this can
significantly decrease performance.  Note, that this does not fix the
inconsistencies but hides some of them from the user.</dd><dt><span class="term"><span class="strong"><strong>Regular Clean-ups</strong></span></span></dt><dd>Run regular batch-jobs to repair inconsistencies
in the graph using <a class="xref" href="hadoop-tp3.html" title="Chapter&nbsp;35.&nbsp;JanusGraph with TinkerPop&#8217;s Hadoop-Gremlin">Chapter&nbsp;35, <i>JanusGraph with TinkerPop&#8217;s Hadoop-Gremlin</i></a>.  This is the only strategy that
can address all inconsistencies and effectively repair them. We will
provide increasing support for such repairs in future versions of
Faunus.</dd><dt><span class="term"><span class="strong"><strong>Soft Deletes</strong></span></span></dt><dd>Instead of deleting vertices, they are marked as deleted which keeps them in the graph for future analysis but hides them from user-facing transactions.</dd></dl></div></div></div></div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced-schema.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="advanced.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="failure-recovery.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;28.&nbsp;Advanced Schema&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;30.&nbsp;Failure &amp; Recovery</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="http://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>