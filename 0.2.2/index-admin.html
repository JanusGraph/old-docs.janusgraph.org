<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;32.&nbsp;Index Management</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="advanced.html" title="Part&nbsp;V.&nbsp;Advanced Topics"><link rel="prev" href="failure-recovery.html" title="Chapter&nbsp;31.&nbsp;Failure &amp; Recovery"><link rel="next" href="bulk-loading.html" title="Chapter&nbsp;33.&nbsp;Bulk Loading"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="http://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="http://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="http://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="http://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right dropdown"><a href="https://docs.janusgraph.org/latest/doc-versions.html">Other Doc Versions</a><div class="dropdown-content"><a href="https://docs.janusgraph.org/latest/index.html">Latest</a><a href="https://docs.janusgraph.org/0.3.0/index.html">Version 0.3.0</a><a href="https://docs.janusgraph.org/0.2.2/index.html">Version 0.2.2</a><a href="https://docs.janusgraph.org/0.2.1/index.html">Version 0.2.1</a><a href="https://docs.janusgraph.org/0.2.0/index.html">Version 0.2.0</a><a href="https://docs.janusgraph.org/0.1.1/index.html">Version 0.1.1</a><a href="https://docs.janusgraph.org/0.1.0/index.html">Version 0.1.0</a></div></li><li class="header-item-right"><a href="index.html">Documentation (0.2.2)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="advanced.html">Advanced Topics</a></span> &gt; <span class="breadcrumb-node">Index Management</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="index-admin"></a>Chapter&nbsp;32.&nbsp;Index Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="index-admin.html#reindex">32.1. Reindexing</a></span></dt><dd><dl><dt><span class="section"><a href="index-admin.html#_overview">32.1.1. Overview</a></span></dt><dt><span class="section"><a href="index-admin.html#_prior_to_reindex">32.1.2. Prior to Reindex</a></span></dt><dt><span class="section"><a href="index-admin.html#_preparing_to_reindex">32.1.3. Preparing to Reindex</a></span></dt><dt><span class="section"><a href="index-admin.html#_executing_a_reindex_job_on_mapreduce">32.1.4. Executing a Reindex Job on MapReduce</a></span></dt><dt><span class="section"><a href="index-admin.html#_executing_a_reindex_job_on_janusgraphmanagement">32.1.5. Executing a Reindex job on JanusGraphManagement</a></span></dt></dl></dd><dt><span class="section"><a href="index-admin.html#mr-index-removal">32.2. Index Removal</a></span></dt><dd><dl><dt><span class="section"><a href="index-admin.html#_overview_2">32.2.1. Overview</a></span></dt><dt><span class="section"><a href="index-admin.html#_preparing_for_index_removal">32.2.2. Preparing for Index Removal</a></span></dt><dt><span class="section"><a href="index-admin.html#_executing_an_index_removal_job_on_mapreduce">32.2.3. Executing an Index Removal Job on MapReduce</a></span></dt><dt><span class="section"><a href="index-admin.html#_executing_an_index_removal_job_on_janusgraphmanagement">32.2.4. Executing an Index Removal job on JanusGraphManagement</a></span></dt></dl></dd><dt><span class="section"><a href="index-admin.html#_common_problems_with_index_management">32.3. Common Problems with Index Management</a></span></dt><dd><dl><dt><span class="section"><a href="index-admin.html#_illegalargumentexception_when_starting_job">32.3.1. IllegalArgumentException when starting job</a></span></dt><dt><span class="section"><a href="index-admin.html#_could_not_find_index">32.3.2. Could not find index</a></span></dt><dt><span class="section"><a href="index-admin.html#_cassandra_mappers_fail_with_too_many_open_files">32.3.3. Cassandra Mappers Fail with "Too many open files"</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reindex"></a>32.1.&nbsp;Reindexing</h2></div></div></div><p><a class="xref" href="indexes.html#graph-indexes" title="10.1.&nbsp;Graph Index">Section&nbsp;10.1, &#8220;Graph Index&#8221;</a> and <a class="xref" href="indexes.html#vertex-indexes" title="10.2.&nbsp;Vertex-centric Indexes">Section&nbsp;10.2, &#8220;Vertex-centric Indexes&#8221;</a> describe how to build graph-global and vertex-centric indexes to improve query performance. These indexes are immediately available if the indexed keys or labels have been newly defined in the same management transaction. In this case, there is no need to reindex the graph and this section can be skipped. If the indexed keys and labels already existed prior to index construction it is necessary to reindex the entire graph in order to ensure that the index contains previously added elements. This section describes the reindexing process.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>Reindexing is a manual process comprised of multiple steps. These steps must be carefully followed in the right order to avoid index inconsistencies.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview"></a>32.1.1.&nbsp;Overview</h3></div></div></div><p>JanusGraph can begin writing incremental index updates right after an index is defined.  However, before the index is complete and usable, JanusGraph must also take a one-time read pass over all existing graph elements associated with the newly indexed schema type(s).  Once this reindexing job has completed, the index is fully populated and ready to be used. The index must then be enabled to be used during query processing.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_prior_to_reindex"></a>32.1.2.&nbsp;Prior to Reindex</h3></div></div></div><p>The starting point of the reindexing process is the construction of an index. Refer to <a class="xref" href="indexes.html" title="Chapter&nbsp;10.&nbsp;Indexing for Better Performance">Chapter&nbsp;10, <i>Indexing for Better Performance</i></a> for a complete discussion of global graph and vertex-centric indexes. Note, that a global graph index is uniquely identified by its name. A vertex-centric index is uniquely identified by the combination of its name and the edge label or property key on which the index is defined - the name of the latter is referred to as the <span class="strong"><strong>index type</strong></span> in this section and only applies to vertex-centric indexes.</p><p>After building a new index against existing schema elements it is recommended to wait a few minutes for the index to be announced to the cluster. Note the index name (and the index type in case of a vertex-centric index) since this information is needed when reindexing.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_preparing_to_reindex"></a>32.1.3.&nbsp;Preparing to Reindex</h3></div></div></div><p>There is a choice between two execution frameworks for reindex jobs:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">MapReduce</li><li class="listitem">JanusGraphManagement</li></ul></div><p>Reindex on MapReduce supports large, horizontally-distributed databases.  Reindex on JanusGraphManagement spawns a single-machine OLAP job.  This is intended for convenience and speed on those databases small enough to be handled by one machine.</p><p>Reindexing requires:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The index name (a string&#8201;&#8212;&#8201;the user provides this to JanusGraph when building a new index)</li><li class="listitem">The index type (a string&#8201;&#8212;&#8201;the name of the edge label or property key on which the vertex-centric index is built). This applies only to vertex-centric indexes - leave blank for global graph indexes.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_a_reindex_job_on_mapreduce"></a>32.1.4.&nbsp;Executing a Reindex Job on MapReduce</h3></div></div></div><p>The recommended way to generate and run a reindex job on MapReduce is through the <code class="literal">MapReduceIndexManagement</code> class.  Here is a rough outline of the steps to run a reindex job using this class:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Open a <code class="literal">JanusGraph</code> instance</li><li class="listitem">Pass the graph instance into <code class="literal">MapReduceIndexManagement</code>'s constructor</li><li class="listitem">Call <code class="literal">updateIndex(&lt;index&gt;, SchemaAction.REINDEX)</code> on the <code class="literal">MapReduceIndexManagement</code> instance</li><li class="listitem">If the index has not yet been enabled, enable it through <code class="literal">JanusGraphManagement</code></li></ul></div><p>This class implements an <code class="literal">updateIndex</code> method that supports only the <code class="literal">REINDEX</code> and <code class="literal">REMOVE_INDEX</code> actions for its <code class="literal">SchemaAction</code> parameter.  The class starts a Hadoop MapReduce job using the Hadoop configuration and jars on the classpath.  Both Hadoop 1 and 2 are supported.  This class gets metadata about the index and storage backend (e.g. the Cassandra partitioner) from the <code class="literal">JanusGraph</code> instance given to its constructor.</p><pre class="programlisting">graph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>JanusGraphFactory.open<span class="hl-gremlin-func">(</span>...<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mr<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>new<span class="hl-gremlin-func"> </span>MapReduceIndexManagement<span class="hl-gremlin-func">(</span>graph<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mr.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getRelationIndex<span class="hl-gremlin-func">(</span>mgmt.getRelationType<span class="hl-gremlin-func">(</span><span class="hl-string">"battled"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"battlesByTime"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_reindex_example_on_mapreduce"></a>32.1.4.1.&nbsp;Reindex Example on MapReduce</h4></div></div></div><p>The following Gremlin snippet outlines all steps of the MapReduce reindex process in one self-contained example using minimal dummy data against the Cassandra storage backend.</p><pre class="programlisting"><em class="hl-comment">// Open a graph</em><span class="hl-gremlin-func">
</span>graph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>JanusGraphFactory.open<span class="hl-gremlin-func">(</span><span class="hl-string">"conf/janusgraph-cql-es.properties"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.traversal<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Define a property</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>desc<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.makePropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">"desc"</span><span class="hl-gremlin-func">)</span>.dataType<span class="hl-gremlin-func">(</span>String.class<span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Insert some data</em><span class="hl-gremlin-func">
</span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-string">"desc"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"foo bar"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.<span class="hl-gremlin-func">addVertex(</span><span class="hl-string">"desc"</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"foo baz"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Run a query -- note the planner warning recommending the use of an index</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">"desc"</span>,<span class="hl-gremlin-func"> </span>containsText<span class="hl-gremlin-func">(</span><span class="hl-string">"baz"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Create an index</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span>desc<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getPropertyKey<span class="hl-gremlin-func">(</span><span class="hl-string">"desc"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mixedIndex<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.buildIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"mixedExample"</span>,<span class="hl-gremlin-func"> </span>Vertex.class<span class="hl-gremlin-func">)</span>.addKey<span class="hl-gremlin-func">(</span>desc<span class="hl-gremlin-func">)</span>.buildMixedIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"search"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Rollback or commit transactions on the graph which predate the index definition</em><span class="hl-gremlin-func">
</span>graph.tx<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Block until the SchemaStatus transitions from INSTALLED to REGISTERED</em><span class="hl-gremlin-func">
</span>report<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">"mixedExample"</span><span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Run a JanusGraph-Hadoop job to reindex</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mr<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>new<span class="hl-gremlin-func"> </span>MapReduceIndexManagement<span class="hl-gremlin-func">(</span>graph<span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mr.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"mixedExample"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Enable the index</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"mixedExample"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span>SchemaAction.ENABLE_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Block until the SchemaStatus is ENABLED</em><span class="hl-gremlin-func">
</span>mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>report<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">"mixedExample"</span><span class="hl-gremlin-func">)</span>.status<span class="hl-gremlin-func">(</span>SchemaStatus.ENABLED<span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.roll<span class="hl-gremlin-func">back(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Run a query -- JanusGraph will use the new index, no planner warning</em><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">"desc"</span>,<span class="hl-gremlin-func"> </span>containsText<span class="hl-gremlin-func">(</span><span class="hl-string">"baz"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span><span class="hl-gremlin-func">
</span><em class="hl-comment">// Concerned that JanusGraph could have read cache in that last query, instead of relying on the index?</em><span class="hl-gremlin-func">
</span><em class="hl-comment">// Start a new instance to rule out cache hits.  Now we're definitely using the index.</em><span class="hl-gremlin-func">
</span>graph.close<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>graph<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>JanusGraphFactory.open<span class="hl-gremlin-func">(</span><span class="hl-string">"conf/janusgraph-cql-es.properties"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>g.<span class="hl-gremlin-func">V(</span><span class="hl-gremlin-func">)</span>.<span class="hl-gremlin-func">has(</span><span class="hl-string">"desc"</span>,<span class="hl-gremlin-func"> </span>containsText<span class="hl-gremlin-func">(</span><span class="hl-string">"baz"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">)</span></pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_a_reindex_job_on_janusgraphmanagement"></a>32.1.5.&nbsp;Executing a Reindex job on JanusGraphManagement</h3></div></div></div><p>To run a reindex job on JanusGraphManagement, invoke <code class="literal">JanusGraphManagement.updateIndex</code> with the <code class="literal">SchemaAction.REINDEX</code> argument.  For example:</p><pre class="programlisting">m<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>i<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>m.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'indexName'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>m.updateIndex<span class="hl-gremlin-func">(</span>i,<span class="hl-gremlin-func"> </span>SchemaAction.REINDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>m.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_example_for_janusgraphmanagement"></a>32.1.5.1.&nbsp;Example for JanusGraphManagement</h4></div></div></div><p>The following loads some sample data into a BerkeleyDB-backed JanusGraph database, defines an index after the fact, reindexes using JanusGraphManagement, and finally enables and uses the index:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.janusgraph.graphdb.database.management.ManagementSystem

<em class="hl-comment">// Load some data from a file without any predefined schema</em>
graph = JanusGraphFactory.open(<span class="hl-string">'conf/janusgraph-berkeleyje.properties'</span>)
g = graph.traversal()
m = graph.openManagement()
m.makePropertyKey(<span class="hl-string">'name'</span>).dataType(String.<strong class="hl-keyword">class</strong>).cardinality(Cardinality.LIST).make()
m.makePropertyKey(<span class="hl-string">'lang'</span>).dataType(String.<strong class="hl-keyword">class</strong>).cardinality(Cardinality.LIST).make()
m.makePropertyKey(<span class="hl-string">'age'</span>).dataType(Integer.<strong class="hl-keyword">class</strong>).cardinality(Cardinality.LIST).make()
m.commit()
graph.io(IoCore.gryo()).readGraph(<span class="hl-string">'data/tinkerpop-modern.gio'</span>)
graph.tx().commit()

<em class="hl-comment">// Run a query -- note the planner warning recommending the use of an index</em>
g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'lop'</span>)
graph.tx().rollback()

<em class="hl-comment">// Create an index</em>
m = graph.openManagement()
m.buildIndex(<span class="hl-string">'names'</span>, Vertex.<strong class="hl-keyword">class</strong>).addKey(m.getPropertyKey(<span class="hl-string">'name'</span>)).buildCompositeIndex()
m.commit()
graph.tx().commit()

<em class="hl-comment">// Block until the SchemaStatus transitions from INSTALLED to REGISTERED</em>
ManagementSystem.awaitGraphIndexStatus(graph, <span class="hl-string">'names'</span>).status(SchemaStatus.REGISTERED).call()

<em class="hl-comment">// Reindex using JanusGraphManagement</em>
m = graph.openManagement()
i = m.getGraphIndex(<span class="hl-string">'names'</span>)
m.updateIndex(i, SchemaAction.REINDEX)
m.commit()

<em class="hl-comment">// Enable the index</em>
ManagementSystem.awaitGraphIndexStatus(graph, <span class="hl-string">'names'</span>).status(SchemaStatus.ENABLED).call()

<em class="hl-comment">// Run a query -- JanusGraph will use the new index, no planner warning</em>
g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'lop'</span>)
graph.tx().rollback()

<em class="hl-comment">// Concerned that JanusGraph could have read cache in that last query, instead of relying on the index?</em>
<em class="hl-comment">// Start a new instance to rule out cache hits.  Now we're definitely using the index.</em>
graph.close()
graph = JanusGraphFactory.open(<span class="hl-string">"conf/janusgraph-berkeleyje.properties"</span>)
g = graph.traversal()
g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'lop'</span>)</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mr-index-removal"></a>32.2.&nbsp;Index Removal</h2></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>Index removal is a manual process comprised of multiple steps. These steps must be carefully followed in the right order to avoid index inconsistencies.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_2"></a>32.2.1.&nbsp;Overview</h3></div></div></div><p>Index removal is a two-stage process.  In the first stage, one JanusGraph signals to all others via the storage backend that the index is slated for deletion.  This changes the index&#8217;s state to <code class="literal">DISABLED</code>.  At that point, JanusGraph stops using the index to answer queries and stops incrementally updating the index.  Index-related data in the storage backend remains present but ignored.</p><p>The second stage depends on whether the index is mixed or composite.  A composite index can be deleted via JanusGraph.  As with reindexing, removal can be done through either MapReduce or JanusGraphManagement.  However, a mixed index must be manually dropped in the index backend; JanusGraph does not provide an automated mechanism to delete an index from its index backend.</p><p>Index removal deletes everything associated with the index except its schema definition and its <code class="literal">DISABLED</code> state.  This schema stub for the index remains even after deletion, though its storage footprint is negligible and fixed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_preparing_for_index_removal"></a>32.2.2.&nbsp;Preparing for Index Removal</h3></div></div></div><p>If the index is currently enabled, it should first be disabled.  This is done through the <code class="literal">ManagementSystem</code>.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>rindex<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getRelationIndex<span class="hl-gremlin-func">(</span>mgmt.getRelationType<span class="hl-gremlin-func">(</span><span class="hl-string">"battled"</span><span class="hl-gremlin-func">)</span>,<span class="hl-gremlin-func"> </span><span class="hl-string">"battlesByTime"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>rindex,<span class="hl-gremlin-func"> </span>SchemaAction.DISABLE_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>gindex<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byName"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>gindex,<span class="hl-gremlin-func"> </span>SchemaAction.DISABLE_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>Once the status of all keys on the index changes to <code class="literal">DISABLED</code>, the index is ready to be removed.  A utility in ManagementSystem can automate the wait-for-<code class="literal">DISABLED</code> step:</p><pre class="programlisting">ManagementSystem.awaitGraphIndexStatus<span class="hl-gremlin-func">(</span>graph,<span class="hl-gremlin-func"> </span><span class="hl-string">'byName'</span><span class="hl-gremlin-func">)</span>.status<span class="hl-gremlin-func">(</span>SchemaStatus.DISABLED<span class="hl-gremlin-func">)</span>.call<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>After a composite index is <code class="literal">DISABLED</code>, there is a choice between two execution frameworks for its removal:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">MapReduce</li><li class="listitem">JanusGraphManagement</li></ul></div><p>Index removal on MapReduce supports large, horizontally-distributed databases.  Index removal on JanusGraphManagement spawns a single-machine OLAP job.  This is intended for convenience and speed on those databases small enough to be handled by one machine.</p><p>Index removal requires:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The index name (a string&#8201;&#8212;&#8201;the user provides this to JanusGraph when building a new index)</li><li class="listitem">The index type (a string&#8201;&#8212;&#8201;the name of the edge label or property key on which the vertex-centric index is built). This applies only to vertex-centric indexes - leave blank for global graph indexes.</li></ul></div><p>As noted in the overview, a mixed index must be manually dropped from the indexing backend.  Neither the MapReduce framework nor the JanusGraphManagement framework will delete a mixed backend from the indexing backend.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_an_index_removal_job_on_mapreduce"></a>32.2.3.&nbsp;Executing an Index Removal Job on MapReduce</h3></div></div></div><p>As with reindexing, the recommended way to generate and run an index removal job on MapReduce is through the <code class="literal">MapReduceIndexManagement</code> class.  Here is a rough outline of the steps to run an index removal job using this class:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Open a <code class="literal">JanusGraph</code> instance</li><li class="listitem">If the index has not yet been disabled, disable it through <code class="literal">JanusGraphManagement</code></li><li class="listitem">Pass the graph instance into <code class="literal">MapReduceIndexManagement</code>'s constructor</li><li class="listitem">Call <code class="literal">updateIndex(&lt;index&gt;, SchemaAction.REMOVE_INDEX)</code></li></ul></div><p>A commented code example follows in the next subsection.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_example_for_mapreduce"></a>32.2.3.1.&nbsp;Example for MapReduce</h4></div></div></div><pre class="programlisting"><strong class="hl-keyword">import</strong> org.janusgraph.graphdb.database.management.ManagementSystem

<em class="hl-comment">// Load the "Graph of the Gods" sample data</em>
graph = JanusGraphFactory.open(<span class="hl-string">'conf/janusgraph-cql-es.properties'</span>)
g = graph.traversal()
GraphOfTheGodsFactory.load(graph)

g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'jupiter'</span>)

<em class="hl-comment">// Disable the "name" composite index</em>
m = graph.openManagement()
nameIndex = m.getGraphIndex(<span class="hl-string">'name'</span>)
m.updateIndex(nameIndex, SchemaAction.DISABLE_INDEX).get()
m.commit()
graph.tx().commit()

<em class="hl-comment">// Block until the SchemaStatus transitions from INSTALLED to REGISTERED</em>
ManagementSystem.awaitGraphIndexStatus(graph, <span class="hl-string">'name'</span>).status(SchemaStatus.DISABLED).call()

<em class="hl-comment">// Delete the index using MapReduceIndexJobs</em>
m = graph.openManagement()
mr = <strong class="hl-keyword">new</strong> MapReduceIndexManagement(graph)
future = mr.updateIndex(m.getGraphIndex(<span class="hl-string">'name'</span>), SchemaAction.REMOVE_INDEX)
m.commit()
graph.tx().commit()
future.get()

<em class="hl-comment">// Index still shows up in management interface as DISABLED -- this is normal</em>
m = graph.openManagement()
idx = m.getGraphIndex(<span class="hl-string">'name'</span>)
idx.getIndexStatus(m.getPropertyKey(<span class="hl-string">'name'</span>))
m.rollback()

<em class="hl-comment">// JanusGraph should issue a warning about this query requiring a full scan</em>
g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'jupiter'</span>)</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_an_index_removal_job_on_janusgraphmanagement"></a>32.2.4.&nbsp;Executing an Index Removal job on JanusGraphManagement</h3></div></div></div><p>To run an index removal job on JanusGraphManagement, invoke <code class="literal">JanusGraphManagement.updateIndex</code> with the <code class="literal">SchemaAction.REMOVE_INDEX</code> argument.  For example:</p><pre class="programlisting">m<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>i<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>m.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">'indexName'</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>m.updateIndex<span class="hl-gremlin-func">(</span>i,<span class="hl-gremlin-func"> </span>SchemaAction.REMOVE_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>m.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_example_for_janusgraphmanagement_2"></a>32.2.4.1.&nbsp;Example for JanusGraphManagement</h4></div></div></div><p>The following loads some indexed sample data into a BerkeleyDB-backed JanusGraph database, then disables and removes the index through JanusGraphManagement:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.janusgraph.graphdb.database.management.ManagementSystem

<em class="hl-comment">// Load the "Graph of the Gods" sample data</em>
graph = JanusGraphFactory.open(<span class="hl-string">'conf/janusgraph-cql-es.properties'</span>)
g = graph.traversal()
GraphOfTheGodsFactory.load(graph)

g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'jupiter'</span>)

<em class="hl-comment">// Disable the "name" composite index</em>
m = graph.openManagement()
nameIndex = m.getGraphIndex(<span class="hl-string">'name'</span>)
m.updateIndex(nameIndex, SchemaAction.DISABLE_INDEX).get()
m.commit()
graph.tx().commit()

<em class="hl-comment">// Block until the SchemaStatus transitions from INSTALLED to REGISTERED</em>
ManagementSystem.awaitGraphIndexStatus(graph, <span class="hl-string">'name'</span>).status(SchemaStatus.DISABLED).call()

<em class="hl-comment">// Delete the index using JanusGraphManagement</em>
m = graph.openManagement()
nameIndex = m.getGraphIndex(<span class="hl-string">'name'</span>)
future = m.updateIndex(nameIndex, SchemaAction.REMOVE_INDEX)
m.commit()
graph.tx().commit()

future.get()

m = graph.openManagement()
nameIndex = m.getGraphIndex(<span class="hl-string">'name'</span>)

g.V().has(<span class="hl-string">'name'</span>, <span class="hl-string">'jupiter'</span>)</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_common_problems_with_index_management"></a>32.3.&nbsp;Common Problems with Index Management</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_illegalargumentexception_when_starting_job"></a>32.3.1.&nbsp;IllegalArgumentException when starting job</h3></div></div></div><p>When a reindexing job is started shortly after a the index has been built, the job might fail with an exception like one of the following:</p><pre class="programlisting">The index mixedExample is in an invalid state and cannot be indexed.
The following index keys have invalid status: desc has status INSTALLED
(status must be one of [REGISTERED, ENABLED])</pre><pre class="programlisting">The index mixedExample is in an invalid state and cannot be indexed.
The index has status INSTALLED, but one of [REGISTERED, ENABLED] is required</pre><p>When an index is built, its existence is broadcast to all other JanusGraph instances in the cluster. Those must acknowledge the existence of the index before the reindexing process can be started. The acknowledgments can take a while to come in depending on the size of the cluster and the connection speed. Hence, one should wait a few minutes after building the index and before starting the reindex process.</p><p>Note, that the acknowledgment might fail due to JanusGraph instance failure. In other words, the cluster might wait indefinitely on the acknowledgment of a failed instance. In this case, the user must manually remove the failed instance from the cluster registry as described in <a class="xref" href="failure-recovery.html" title="Chapter&nbsp;31.&nbsp;Failure &amp; Recovery">Chapter&nbsp;31, <i>Failure &amp; Recovery</i></a>. After the cluster state has been restored, the acknowledgment process must be reinitiated by manually registering the index again in the management system.</p><pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>rindex<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getRelationIndex<span class="hl-gremlin-func">(</span>mgmt.getRelationType<span class="hl-gremlin-func">(</span><span class="hl-string">"battled"</span><span class="hl-gremlin-func">)</span>,<span class="hl-string">"battlesByTime"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>rindex,<span class="hl-gremlin-func"> </span>SchemaAction.REGISTER_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>gindex<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>mgmt.getGraphIndex<span class="hl-gremlin-func">(</span><span class="hl-string">"byName"</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.updateIndex<span class="hl-gremlin-func">(</span>gindex,<span class="hl-gremlin-func"> </span>SchemaAction.REGISTER_INDEX<span class="hl-gremlin-func">)</span>.get<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre><p>After waiting a few minutes for the acknowledgment to arrive the reindex job should start successfully.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_could_not_find_index"></a>32.3.2.&nbsp;Could not find index</h3></div></div></div><p>This exception in the reindexing job indicates that an index with the given name does not exist or that the name has not been specified correctly. When reindexing a global graph index, only the name of the index as defined when building the index should be specified. When reindexing a global graph index, the name of the index must be given in addition to the name of the edge label or property key on which the vertex-centric index is defined.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_cassandra_mappers_fail_with_too_many_open_files"></a>32.3.3.&nbsp;Cassandra Mappers Fail with "Too many open files"</h3></div></div></div><p>The end of the exception stacktrace may look like this:</p><pre class="screen">java.net.SocketException: Too many open files
        at java.net.Socket.createImpl(Socket.java:447)
        at java.net.Socket.getImpl(Socket.java:510)
        at java.net.Socket.setSoLinger(Socket.java:988)
        at org.apache.thrift.transport.TSocket.initSocket(TSocket.java:118)
        at org.apache.thrift.transport.TSocket.&lt;init&gt;(TSocket.java:109)</pre><p>When running Cassandra with virtual nodes enabled, the number of virtual nodes seems to set a floor under the number of mappers.  Cassandra may generate more mappers than virtual nodes for clusters with lots of data, but it seems to generate at least as many mappers as there are virtual nodes even though the cluster might be empty or close to empty.  The default is 256 as of this writing.</p><p>Each mapper opens and quickly closes several sockets to Cassandra.  The kernel on the client side of those closed sockets goes into asynchronous TIME_WAIT, since Thrift uses SO_LINGER.  Only a small number of sockets are open at any one time&#8201;&#8212;&#8201;usually low single digits&#8201;&#8212;&#8201;but potentially many lingering sockets can accumulate in TIME_WAIT.  This accumulation is most pronounced when running a reindex job locally (not on a distributed MapReduce cluster), since all of those client-side TIME_WAIT sockets are lingering on a single client machine instead of being spread out across many machines in a cluster.   Combined with the floor of 256 mappers, a reindex job can open thousands of sockets of the course of its execution.  When these sockets all linger in TIME_WAIT on the same client, they have the potential to reach the open-files ulimit, which also controls the number of open sockets.  The open-files ulimit is often set to 1024.</p><p>Here are a few suggestions for dealing with the "Too many open files" problem during reindexing on a single machine:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Reduce the maximum size of the Cassandra connection pool.  For example, consider setting the cassandrathrift storage backend&#8217;s <code class="literal">max-active</code> and <code class="literal">max-idle</code> options to 1 each, and setting <code class="literal">max-total</code> to -1.  See <a class="xref" href="config-ref.html" title="Chapter&nbsp;14.&nbsp;Configuration Reference">Chapter&nbsp;14, <i>Configuration Reference</i></a> for full listings of connection pool settings on the Cassandra storage backends.</li><li class="listitem">Increase the <code class="literal">nofile</code> ulimit.  The ideal value depends on the size of the Cassandra dataset and the throughput of the reindex mappers; if starting at 1024, try an order of magnitude larger: 10000.  This is just necessary to sustain lingering TIME_WAIT sockets.  The reindex job won&#8217;t try to open nearly that many sockets at once.</li><li class="listitem">Run the reindex task on a multi-node MapReduce cluster to spread out the socket load.</li></ul></div></div></div></div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="failure-recovery.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="advanced.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="bulk-loading.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;31.&nbsp;Failure &amp; Recovery&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;33.&nbsp;Bulk Loading</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="http://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>