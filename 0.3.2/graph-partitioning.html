<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;38.&nbsp;Graph Partitioning</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="JanusGraph Documentation"><link rel="up" href="advanced.html" title="Part&nbsp;VI.&nbsp;Advanced Topics"><link rel="prev" href="bulk-loading.html" title="Chapter&nbsp;37.&nbsp;Bulk Loading"><link rel="next" href="serializer.html" title="Chapter&nbsp;39.&nbsp;Datatype and Attribute Serializer Configuration"><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-1.11.0.js"></script><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript" src="js/jquery/jquery-migrate-1.2.1.min.js"></script><link xmlns:d="https://docbook.org/ns/docbook" rel="stylesheet" id="inline-blob-janusgraph-docs-specific" href="css/docs.css" type="text/css" media="all"><link xmlns:d="https://docbook.org/ns/docbook" rel="apple-touch-icon" type="image/png" href="images/janusgraph-logomark.png"><script xmlns:d="https://docbook.org/ns/docbook" type="text/javascript">
      WebFontConfig = {
        google: {
          families: [
            "Lato:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Open+Sans:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese",
            "Antic+Slab:400,400italic,700,700italic:latin,greek-ext,cyrillic,latin-ext,greek,cyrillic-ext,vietnamese"
          ]
        }
      };
      (function() {
      var wf = document.createElement('script');
      wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	wf.type = 'text/javascript';
	wf.async = 'true';
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(wf, s);
	})();
    </script></head><body xmlns:d="https://docbook.org/ns/docbook" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="wrapper"><div class="header-wrapper"><header id="header"><ul class="header-list"><li class="header-item"><a href="https://janusgraph.org"><img src="images/janusgraph-logo.png" alt="JanusGraph" class="normal_logo"></a></li><li class="header-item-right"><a href="https://github.com/JanusGraph/janusgraph/releases">Download JanusGraph</a></li><li class="header-item-right dropdown"><a href="https://docs.janusgraph.org/latest/doc-versions.html">Other Doc Versions</a><div class="dropdown-content"><a href="https://docs.janusgraph.org/latest/index.html">Latest</a><a href="https://docs.janusgraph.org/0.3.2/index.html">Version 0.3.2</a><a href="https://docs.janusgraph.org/0.3.1/index.html">Version 0.3.1</a><a href="https://docs.janusgraph.org/0.3.0/index.html">Version 0.3.0</a><a href="https://docs.janusgraph.org/0.2.3/index.html">Version 0.2.3</a><a href="https://docs.janusgraph.org/0.2.2/index.html">Version 0.2.2</a><a href="https://docs.janusgraph.org/0.2.1/index.html">Version 0.2.1</a><a href="https://docs.janusgraph.org/0.2.0/index.html">Version 0.2.0</a><a href="https://docs.janusgraph.org/0.1.1/index.html">Version 0.1.1</a><a href="https://docs.janusgraph.org/0.1.0/index.html">Version 0.1.0</a></div></li><li class="header-item-right"><a href="index.html">Documentation (0.3.2)</a></li></ul></header></div><div id="main" class="clearfix width-100"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">JanusGraph Documentation</a></span> &gt; <span class="breadcrumb-link"><a href="advanced.html">Advanced Topics</a></span> &gt; <span class="breadcrumb-node">Graph Partitioning</span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="graph-partitioning"></a>Chapter&nbsp;38.&nbsp;Graph Partitioning</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="graph-partitioning.html#_edge_cut">38.1. Edge Cut</a></span></dt><dt><span class="section"><a href="graph-partitioning.html#_vertex_cut">38.2. Vertex Cut</a></span></dt><dt><span class="section"><a href="graph-partitioning.html#_graph_partitioning_faq">38.3. Graph Partitioning FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="graph-partitioning.html#_random_vs_explicit_partitioning">38.3.1. Random vs. Explicit Partitioning</a></span></dt></dl></dd></dl></div>

<p>When JanusGraph is deployed on a cluster of multiple storage backend instances, the graph is partitioned across those machines. Since JanusGraph stores the graph in an adjacency list representation the assignment of vertices to machines determines the partitioning. By default, JanusGraph uses a random partitioning strategy that randomly assigns vertices to machines. Random partitioning is very efficient, requires no configuration, and results in balanced partitions. Currently explicit partitioning is not supported.</p>
<pre class="programlisting"><span class="hl-attribute">cluster.max-partitions </span>= 32
<span class="hl-attribute">id.placement </span>= simple</pre>

<p>The configuration option <code class="literal">max-partitions</code> controls how many virtual partitions JanusGraph creates. This number should be roughly twice the number of storage backend instances. If the cluster of storage backend instances is expected to grow, estimate the size of the cluster in the foreseeable future and take this number as the baseline. Setting this number too large will unnecessarily fragment the cluster which can lead to poor performance. This number should be larger than the maximum expected number of nodes in the JanusGraph graph. It must be greater than 1 and a power of 2.</p>
<p>There are two aspects to graph partitioning which can be individually controlled: edge cuts and vertex cuts.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_edge_cut"></a>38.1.&nbsp;Edge Cut</h2></div></div></div>

<p>In assigning vertices to partitions one strives to optimize the assignment such that frequently co-traversed vertices are hosted on the same machine. Assume vertex A is assigned to machine 1 and vertex B is assigned to machine 2. An edge between the vertices is called a <span class="strong"><strong>cut edge</strong></span> because its end points are hosted on separate machines. Traversing this edge as part of a graph query requires communication between the machines which slows down query processing. Hence, it is desirable to reduce the edge cut for frequently traversed edges. That, in turn, requires placing the adjacent vertices of frequently traversed edges in the same partition.</p>
<p>Vertices are placed in a partition by way of the assigned vertex id. A partition is essentially a sequential range of vertex ids. To place a vertex in a particular partition, JanusGraph chooses an id from the partition&#8217;s range of vertex ids. JanusGraph controls the vertex-to-partition assignment through the configured placement strategy. By default, vertices created in the same transaction are assigned to the same partition. This strategy is easy to reason about and works well in situations where frequently co-traversed vertices are created in the same transaction - either by optimizing the loading strategy to that effect or because vertices are naturally added to the graph that way. However, the strategy is limited, leads to imbalanced partitions when data is loaded in large transactions and not the optimal strategy for many use cases. The user can provide a use case specific vertex placement strategy by implementing the <code class="literal">IDPlacementStrategy</code> interface and registering it in the configuration through the <code class="literal">ids.placement</code> option.</p>
<p>When implementing <code class="literal">IDPlacementStrategy</code>, note that partitions are identified by an integer id in the range from 0 to the number of configured virtual partitions minus 1. For our example configuration, there are partitions 0, 1, 2, 3, ..31. Partition ids are not the same as vertex ids. Edge cuts are more meaningful when the JanusGraph servers are on the same hosts as the storage backend. If you have to make a network call to a different host on each hop of a traversal, the benefit of edge cuts and custom placement strategies can be largely nullified.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_vertex_cut"></a>38.2.&nbsp;Vertex Cut</h2></div></div></div>

<p>While edge cut optimization aims to reduce the cross communication and thereby improve query execution, vertex cuts address the hotspot issue caused by vertices with a large number of incident edges. While <a class="link" href="indexes.html#vertex-indexes" title="11.2.&nbsp;Vertex-centric Indexes">vertex-centric indexes</a> effectively address query performance for large degree vertices, vertex cuts are needed to address the hot spot issue on very large graphs.</p>
<p>Cutting a vertex means storing a subset of that vertex&#8217;s adjacency list on each partition in the graph. In other words, the vertex and its adjacency list is partitioned thereby effectively distributing the load on that single vertex across all of the instances in the cluster and removing the hot spot.</p>
<p>JanusGraph cuts vertices by label. A vertex label can be defined as <span class="emphasis"><em>partitioned</em></span> which means that all vertices of that label will be partitioned across the cluster in the manner described above.</p>
<pre class="programlisting">mgmt<span class="hl-gremlin-func"> </span>=<span class="hl-gremlin-func"> </span>graph.openManagement<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'user'</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.makeVertexLabel<span class="hl-gremlin-func">(</span><span class="hl-string">'product'</span><span class="hl-gremlin-func">)</span>.partition<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span>.make<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span><span class="hl-gremlin-func">
</span>mgmt.commit<span class="hl-gremlin-func">(</span><span class="hl-gremlin-func">)</span></pre>

<p>In the example above, <code class="literal">product</code> is defined as a partitioned vertex label whereas <code class="literal">user</code> is a normal label. This configuration is beneficial for situations where there are thousands of products but millions of users and one records transactions between users and products. In that case, the product vertices will have a very high degree and the popular products turns into hot spots if they are not partitioned.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_graph_partitioning_faq"></a>38.3.&nbsp;Graph Partitioning FAQ</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_random_vs_explicit_partitioning"></a>38.3.1.&nbsp;Random vs. Explicit Partitioning</h3></div></div></div>

<p>When the graph is small or accommodated by a few storage instances, it is best to use random partitioning for its simplicity. As a rule of thumb, one should strongly consider enabling explicit graph partitioning and configure a suitable partitioning heuristic when the graph grows into the 10s of billions of edges.</p>
</div>
</div>
</div></div><div class="clearer"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bulk-loading.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="advanced.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="serializer.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;37.&nbsp;Bulk Loading&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;39.&nbsp;Datatype and Attribute Serializer Configuration</td></tr></table></div><div class="footer-wrapper"><footer id="footer"><div class="copyright">
              Copyright &copy; 2017 JanusGraph Authors. All rights reserved.<br>
              The Linux Foundation has registered trademarks and uses trademarks. For a list of<br>
              trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
              Cassandra, Groovy, HBase, Hadoop, Lucene, Solr, and TinkerPop are trademarks of the Apache Software Foundation.<br>
              Berkeley DB and Berkeley DB Java Edition are trademarks of Oracle.<br>
              Documentation generated with <a href="https://www.methods.co.nz/asciidoc/">AsciiDoc</a>, <a href="https://asciidoctor.org/">AsciiDoctor</a>, <a href="http://docbook.sourceforge.net/">DocBook</a>, and <a href="http://saxon.sourceforge.net/">Saxon</a>.
        	  </div></footer></div></div></body></html>